diff --git a/drivers/amlogic/hdmi/hdmi_tx/amlogic_cec.c b/drivers/amlogic/hdmi/hdmi_tx/amlogic_cec.c
index 61fb500..d1d3511 100644
--- a/drivers/amlogic/hdmi/hdmi_tx/amlogic_cec.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/amlogic_cec.c
@@ -36,7 +36,9 @@
 #include <mach/hdmi_tx_reg.h>
 #include <linux/amlogic/hdmi_tx/hdmi_tx_cec.h>
 
-#define CONFIG_TV_DEBUG
+#define CONFIG_TV_DEBUG // for verbose output
+//#undef CONFIG_TV_DEBUG
+bool cec_msg_dbg_en = 1;
 
 MODULE_AUTHOR("Gerald Dachs");
 MODULE_DESCRIPTION("Amlogic CEC driver");
@@ -55,24 +57,16 @@ MODULE_LICENSE("GPL");
 #define CEC_TX_BUFF_SIZE            16
 
 #define DRV_NAME "amlogic_cec"
-#ifndef tvout_dbg
+#ifndef amlogic_cec_log_dbg
 #ifdef CONFIG_TV_DEBUG
-#define tvout_dbg(fmt, ...)					\
+#define amlogic_cec_log_dbg(fmt, ...)					\
 		printk(KERN_INFO "[%s] %s(): " fmt,		\
 		DRV_NAME, __func__, ##__VA_ARGS__)
 #else
-#define tvout_dbg(fmt, ...)
+#define amlogic_cec_log_dbg(fmt, ...)
 #endif
 #endif
 
-static atomic_t hdmi_on = ATOMIC_INIT(0);
-
-bool cec_msg_dbg_en = 1;
-cec_global_info_t cec_global_info;
-
-static hdmitx_dev_t* hdmitx_device = NULL;
-static struct workqueue_struct *cec_workqueue = NULL;
-
 struct cec_rx_list {
 	u8 buffer[CEC_RX_BUFF_SIZE];
 	unsigned char size;
@@ -86,6 +80,12 @@ struct cec_rx_struct {
 	struct list_head list;
 };
 
+struct cec_tx_struct {
+	spinlock_t lock;
+	wait_queue_head_t waitq;
+	atomic_t state;
+};
+
 enum cec_state {
 	STATE_RX,
 	STATE_TX,
@@ -98,58 +98,133 @@ static char banner[] __initdata =
 
 static struct cec_rx_struct cec_rx_struct;
 
-unsigned short cec_log_addr_to_dev_type(unsigned char log_addr)
+static struct cec_tx_struct cec_tx_struct;
+
+static atomic_t hdmi_on = ATOMIC_INIT(0);
+
+cec_global_info_t cec_global_info;
+
+static hdmitx_dev_t* hdmitx_device = NULL;
+static struct workqueue_struct *cec_workqueue = NULL;
+
+static int cec_init_flag = 0;
+
+static void amlogic_cec_set_rx_state(enum cec_state state)
 {
-    unsigned short us = CEC_UNREGISTERED_DEVICE_TYPE;
-    if ((1 << log_addr) & CEC_DISPLAY_DEVICE)
-    {
-        us = CEC_DISPLAY_DEVICE_TYPE;
-    }
-    else if ((1 << log_addr) & CEC_RECORDING_DEVICE)
-    {
-        us = CEC_RECORDING_DEVICE_TYPE;
-    }
-    else if ((1 << log_addr) & CEC_PLAYBACK_DEVICE)
-    {
-        us = CEC_PLAYBACK_DEVICE_TYPE;
-    }
-    else if ((1 << log_addr) & CEC_TUNER_DEVICE)
-    {
-        us = CEC_TUNER_DEVICE_TYPE;
-    }
-    else if ((1 << log_addr) & CEC_AUDIO_SYSTEM_DEVICE)
+    atomic_set(&cec_rx_struct.state, state);
+}
+
+static void amlogic_cec_set_tx_state(enum cec_state state)
+{
+    atomic_set(&cec_tx_struct.state, state);
+}
+
+static void amlogic_cec_msg_dump(char * msg_tag, const unsigned char *data, unsigned char count)
+{
+  int i;
+  int pos;
+  unsigned char msg_log_buf[128] = { 0 };
+
+  if (cec_msg_dbg_en  == 1)
+  {
+      pos = 0;
+      pos += sprintf(msg_log_buf + pos, "msg %s len: %d   dat: ", msg_tag, count);
+      for (i = 0; i < count; ++i)
+      {
+          pos += sprintf(msg_log_buf + pos, "%02x ", data[i]);
+      }
+      pos += sprintf(msg_log_buf + pos, "\n");
+      msg_log_buf[pos] = '\0';
+      hdmi_print(INF, "[amlogic_cec] dump: %s", msg_log_buf);
+  }
+}
+
+static unsigned int amlogic_cec_read_reg(unsigned int reg)
+{
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+    return hdmi_rd_reg(CEC0_BASE_ADDR + reg);
+#endif
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+    return aocec_rd_reg(reg);
+#endif
+}
+
+static void amlogic_cec_write_reg(unsigned int reg, unsigned int value)
+{
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+    hdmi_wr_reg(CEC0_BASE_ADDR + reg, value);
+#endif
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+    aocec_wr_reg(reg, value);
+#endif
+}
+
+static int amlogic_cec_read_hw(unsigned char *data, unsigned char *count)
+{
+    int ret = -1;
+    int valid_msg;
+    int rx_msg_status;
+    int rx_num_msg;
+
+    rx_msg_status = amlogic_cec_read_reg(CEC_RX_MSG_STATUS);
+    rx_num_msg = amlogic_cec_read_reg(CEC_RX_NUM_MSG);
+
+    amlogic_cec_log_dbg("amlogic_cec_read_hw: enter: CEC_RX_MSG_STATUS %d, CEC_RX_NUM_MSG %d\n", rx_msg_status, rx_num_msg);
+
+    valid_msg = (RX_DONE == rx_msg_status) && (1 == rx_num_msg);
+
+    if (valid_msg)
     {
-        us = CEC_AUDIO_SYSTEM_DEVICE_TYPE;
+      int i;
+
+      *count = amlogic_cec_read_reg(CEC_RX_MSG_LENGTH) + 1;
+      for (i = 0; i < (*count) && i < CEC_RX_BUFF_SIZE; ++i)
+      {
+          data[i]= amlogic_cec_read_reg(CEC_RX_MSG_0_HEADER + i);
+      }
+
+      amlogic_cec_msg_dump("RX", data, *count);
+
+      ret = RX_DONE;
     }
 
-    return us;
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+    aml_write_reg32(P_AO_CEC_INTR_CLR, aml_read_reg32(P_AO_CEC_INTR_CLR) | (1 << 2));
+#endif
+    amlogic_cec_write_reg(CEC_RX_MSG_CMD, valid_msg ? RX_ACK_NEXT : RX_ACK_CURRENT);
+    amlogic_cec_write_reg(CEC_RX_MSG_CMD, RX_NO_OP);
+
+    return ret;
 }
 
-void cec_report_physical_address_smp(void)
-{
-    unsigned char msg[5];
-    unsigned char index = cec_global_info.my_node_index;
-    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
-    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
 
-    tvout_dbg("cec_report_physical_address_smp: enter\n");
+static void amlogic_cec_write_hw(const char *data, size_t count)
+{
+  int i;
 
-    msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
-    msg[1] = CEC_OC_REPORT_PHYSICAL_ADDRESS;
-    msg[2] = phy_addr_ab;
-    msg[3] = phy_addr_cd;
-    msg[4] = cec_log_addr_to_dev_type(index);
+  for (i = 0; i < count; ++i)
+  {
+      amlogic_cec_write_reg(CEC_TX_MSG_0_HEADER + i, data[i]);
+  }
+  amlogic_cec_write_reg(CEC_TX_MSG_LENGTH, count - 1);
+  amlogic_cec_write_reg(CEC_TX_MSG_CMD, TX_REQ_CURRENT);
 
-    cec_ll_tx(msg, 5);
+  amlogic_cec_msg_dump("TX", data, count);
+}
 
-    tvout_dbg("cec_report_physical_address_smp: leave\n");
+unsigned short cec_log_addr_to_dev_type(unsigned char log_addr)
+{
+// unused, just to satisfy the linker
+  return log_addr;
 }
 
 void cec_node_init(hdmitx_dev_t* hdmitx_device)
 {
     unsigned long cec_phy_addr;
+    unsigned long spin_flags;
+    struct cec_rx_list *entry;
 
-    tvout_dbg("cec node init: enter\n");
+    amlogic_cec_log_dbg("cec node init: enter\n");
 
     cec_phy_addr = (((hdmitx_device->hdmi_info.vsdb_phy_addr.a) & 0xf) << 12)
                  | (((hdmitx_device->hdmi_info.vsdb_phy_addr.b) & 0xf) << 8)
@@ -159,34 +234,46 @@ void cec_node_init(hdmitx_dev_t* hdmitx_device)
     // If VSDB is not valid,use last or default physical address.
     if (hdmitx_device->hdmi_info.vsdb_phy_addr.valid == 0)
     {
-	tvout_dbg("no valid cec physical address\n");
-	if (aml_read_reg32 (P_AO_DEBUG_REG1))
+	amlogic_cec_log_dbg("no valid cec physical address\n");
+	if (aml_read_reg32(P_AO_DEBUG_REG1))
 	{
-	    tvout_dbg("use last physical address\n");
+	    amlogic_cec_log_dbg("use last physical address\n");
 	}
 	else
 	{
-	    aml_write_reg32 (P_AO_DEBUG_REG1, 0x1000);
-	    tvout_dbg("use default physical address\n");
+	    aml_write_reg32(P_AO_DEBUG_REG1, 0x1000);
+	    amlogic_cec_log_dbg("use default physical address\n");
 	}
     }
     else
     {
-	aml_write_reg32 (P_AO_DEBUG_REG1, cec_phy_addr);
-    }
-    tvout_dbg("physical address:0x%x\n", aml_read_reg32(P_AO_DEBUG_REG1));
+	aml_write_reg32(P_AO_DEBUG_REG1, cec_phy_addr);
+        amlogic_cec_log_dbg("physical address:0x%x\n", aml_read_reg32(P_AO_DEBUG_REG1));
 
-    if (hdmitx_device->cec_init_ready != 0)
-    {
-	tvout_dbg("report physical address:0x%x\n", aml_read_reg32(P_AO_DEBUG_REG1));
-	cec_report_physical_address_smp();
+        if ((hdmitx_device->cec_init_ready != 0) && (hdmitx_device->hpd_state != 0))
+        {
+	    if ((entry = kmalloc(sizeof(struct cec_rx_list), GFP_ATOMIC)) == NULL)
+	    {
+	        amlogic_cec_log_dbg("can't alloc cec_rx_list\n");
+	    }
+	    else
+	    {
+	        // let the libCEC ask for new physical Address
+	        entry->buffer[0] = 0xff;
+	        entry->size = 1;
+	        INIT_LIST_HEAD(&entry->list);
+
+	        spin_lock_irqsave(&cec_rx_struct.lock, spin_flags);
+	        list_add_tail(&entry->list, &cec_rx_struct.list);
+	        amlogic_cec_set_rx_state(STATE_DONE);
+	        spin_unlock_irqrestore(&cec_rx_struct.lock, spin_flags);
+
+                amlogic_cec_log_dbg("trigger libCEC\n");
+	        wake_up_interruptible(&cec_rx_struct.waitq);
+	    }
+        }
     }
-    tvout_dbg("cec node init: cec features ok !\n");
-}
-
-static void amlogic_cec_set_rx_state(enum cec_state state)
-{
-    atomic_set(&cec_rx_struct.state, state);
+    amlogic_cec_log_dbg("cec node init: cec features ok !\n");
 }
 
 static int amlogic_cec_open(struct inode *inode, struct file *file)
@@ -195,7 +282,7 @@ static int amlogic_cec_open(struct inode *inode, struct file *file)
 
     if (atomic_read(&hdmi_on))
     {
-	tvout_dbg("do not allow multiple open for tvout cec\n");
+	amlogic_cec_log_dbg("do not allow multiple open for tvout cec\n");
 	ret = -EBUSY;
     }
     else
@@ -219,12 +306,12 @@ static ssize_t amlogic_cec_read(struct file *file, char __user *buffer,
     unsigned long spin_flags;
     struct cec_rx_list* entry = NULL;
 
-    tvout_dbg("amlogic_cec_read: enter\n");
+    amlogic_cec_log_dbg("amlogic_cec_read: enter\n");
 
     if (wait_event_interruptible(cec_rx_struct.waitq,
 				 atomic_read(&cec_rx_struct.state) == STATE_DONE))
     {
-	tvout_dbg("error during wait on state change\n");
+	amlogic_cec_log_dbg("error during wait on state change\n");
 	return -ERESTARTSYS;
     }
 
@@ -234,7 +321,7 @@ static ssize_t amlogic_cec_read(struct file *file, char __user *buffer,
 
     if (entry == NULL || entry->size > count)
     {
-	tvout_dbg("entry is NULL, or empty\n");
+	amlogic_cec_log_dbg("entry is NULL, or empty\n");
 	retval = -1;
 	goto error_exit;
     }
@@ -260,7 +347,7 @@ error_exit:
 
     spin_unlock_irqrestore(&cec_rx_struct.lock, spin_flags);
 
-    tvout_dbg("amlogic_cec_read: leave\n");
+    amlogic_cec_log_dbg("amlogic_cec_read: leave\n");
 
     return retval;
 }
@@ -268,11 +355,8 @@ error_exit:
 static ssize_t amlogic_cec_write(struct file *file, const char __user *buffer,
 			size_t count, loff_t *ppos)
 {
-    int ret = 0;
-
     char data[CEC_TX_BUFF_SIZE];
-
-    tvout_dbg("amlogic_cec_write: enter\n");
+    amlogic_cec_log_dbg("amlogic_cec_write: enter\n");
 
     /* check data size */
     if (count > CEC_TX_BUFF_SIZE || count == 0)
@@ -284,14 +368,34 @@ static ssize_t amlogic_cec_write(struct file *file, const char __user *buffer,
 	return -EFAULT;
     }
 
-    ret = cec_ll_tx(data, count);
-    if (ret != 1)
+    amlogic_cec_set_tx_state(STATE_TX);
+
+    // just for the case that the first write starts
+    // before the end of amlogic_cec_delayed_init()
+    if (wait_event_interruptible(cec_tx_struct.waitq, hdmitx_device->cec_init_ready == 1))
+    {
+	amlogic_cec_log_dbg("error during wait on state change\n");
+	printk(KERN_ERR "[amlogic] ##### cec write error! #####\n");
+	return -ERESTARTSYS;
+    }
+
+    amlogic_cec_write_hw(data, count);
+
+    if (wait_event_interruptible_timeout(cec_tx_struct.waitq,
+        atomic_read(&cec_tx_struct.state) != STATE_TX, 1 * HZ) <= 0)
+    {
+	amlogic_cec_log_dbg("error during wait on state change\n");
+	printk(KERN_ERR "[amlogic] ##### cec write error! #####\n");
+	return -ERESTARTSYS;
+    }
+
+    if (atomic_read(&cec_tx_struct.state) != STATE_DONE)
     {
-    	tvout_dbg("Message transmit failed, ret=%d\n", ret);
-        return -1;
+	printk(KERN_ERR "[amlogic] ##### cec write error! #####\n");
+	return -1;
     }
 
-    tvout_dbg("amlogic_cec_write: leave\n");
+    amlogic_cec_log_dbg("amlogic_cec_write: leave\n");
 
     return count;
 }
@@ -300,26 +404,22 @@ static long amlogic_cec_ioctl(struct file *file, unsigned int cmd,
 						unsigned long arg)
 {
     unsigned char logical_addr;
+    amlogic_cec_log_dbg("amlogic_cec_ioctl: enter\n");
 
     switch(cmd) {
     case CEC_IOC_SETLADDR:
         if (get_user(logical_addr, (unsigned char __user *)arg))
         {
-            tvout_dbg("Failed to get logical addr from user\n");
+            amlogic_cec_log_dbg("Failed to get logical addr from user\n");
             return -EFAULT;
         }
 
-        cec_global_info.my_node_index = logical_addr;
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
-        hdmi_wr_reg(CEC0_BASE_ADDR+CEC_LOGICAL_ADDR0, (0x1 << 4) | logical_addr);
-#endif
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-        aocec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | logical_addr);
-#endif
-        tvout_dbg("Set logical address: %d\n", logical_addr);
+        amlogic_cec_write_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | logical_addr);
+        amlogic_cec_log_dbg("amlogic_cec_ioctl: Set logical address: %d\n", logical_addr);
         return 0;
 
     case CEC_IOC_GETPADDR:
+        amlogic_cec_log_dbg("amlogic_cec_ioctl: return physical address 0x%x\n", aml_read_reg32(P_AO_DEBUG_REG1));
     	return aml_read_reg32(P_AO_DEBUG_REG1);
     }
 
@@ -357,55 +457,63 @@ static irqreturn_t amlogic_cec_irq_handler(int irq, void *dummy)
 {
     unsigned long spin_flags;
     struct cec_rx_list *entry;
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-    unsigned int intr_stat = 0;
-#endif
+    unsigned int tx_msg_state;
+    unsigned int rx_msg_state;
 
-    tvout_dbg("amlogic_cec_irq_handler: enter\n");
+    amlogic_cec_log_dbg("amlogic_cec_irq_handler: enter\n");
 
     udelay(100); //Delay execution a little. This fixes an issue when HDMI CEC stops working after a while.
 
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
-    tvout_dbg("cec TX status: rx: 0x%x; tx: 0x%x\n", hdmi_rd_reg(CEC0_BASE_ADDR+CEC_RX_MSG_STATUS), hdmi_rd_reg(CEC0_BASE_ADDR+CEC_TX_MSG_STATUS));
-    if (hdmi_rd_reg(CEC0_BASE_ADDR+CEC_RX_MSG_STATUS) != RX_DONE)
-    {
-        return IRQ_HANDLED;
-    }
-#endif
+    tx_msg_state = amlogic_cec_read_reg(CEC_TX_MSG_STATUS);
+    rx_msg_state = amlogic_cec_read_reg(CEC_RX_MSG_STATUS);
 
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-    intr_stat = aml_read_reg32(P_AO_CEC_INTR_STAT);
-    tvout_dbg("aocec irq %x\n", intr_stat);
-    if (intr_stat & (1<<1))
-    {   // aocec tx intr
-        tx_irq_handle();
-        return IRQ_HANDLED;
-    }
-#endif
+    amlogic_cec_log_dbg("cec msg status: rx: 0x%x; tx: 0x%x\n", rx_msg_state, tx_msg_state);
 
-    if ((entry = kmalloc(sizeof(struct cec_rx_list), GFP_ATOMIC)) == NULL)
+    if ((tx_msg_state == TX_DONE) || (tx_msg_state == TX_ERROR))
     {
-        tvout_dbg("can't alloc cec_rx_list\n");
-        return IRQ_HANDLED;
+	amlogic_cec_write_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+
+	switch (tx_msg_state) {
+	  case TX_ERROR :
+	    amlogic_cec_set_tx_state(STATE_ERROR);
+	    break;
+	  case TX_DONE :
+	    amlogic_cec_set_tx_state(STATE_DONE);
+	    break;
+	  default :
+	    amlogic_cec_log_dbg("unexpected ts message state: 0x%x", tx_msg_state);
+	    break;
+	}
+	wake_up_interruptible(&cec_tx_struct.waitq);
     }
 
-    if ((-1) == cec_ll_rx(entry->buffer, &entry->size))
+    if (rx_msg_state == RX_DONE)
     {
-        kfree(entry);
-        tvout_dbg("amlogic_cec_irq_handler: nothing to read\n");
-        return IRQ_HANDLED;
-    }
 
-    INIT_LIST_HEAD(&entry->list);
+	if ((entry = kmalloc(sizeof(struct cec_rx_list), GFP_ATOMIC)) == NULL)
+	{
+	    amlogic_cec_log_dbg("can't alloc cec_rx_list\n");
+	    return IRQ_HANDLED;
+	}
 
-    spin_lock_irqsave(&cec_rx_struct.lock, spin_flags);
-    list_add_tail(&entry->list, &cec_rx_struct.list);
-    amlogic_cec_set_rx_state(STATE_DONE);
-    spin_unlock_irqrestore(&cec_rx_struct.lock, spin_flags);
+	if ((-1) == amlogic_cec_read_hw(entry->buffer, &entry->size))
+	{
+	    kfree(entry);
+	    amlogic_cec_log_dbg("amlogic_cec_irq_handler: nothing to read\n");
+	    return IRQ_HANDLED;
+	}
+
+	INIT_LIST_HEAD(&entry->list);
+
+	spin_lock_irqsave(&cec_rx_struct.lock, spin_flags);
+	list_add_tail(&entry->list, &cec_rx_struct.list);
+	amlogic_cec_set_rx_state(STATE_DONE);
+	spin_unlock_irqrestore(&cec_rx_struct.lock, spin_flags);
 
-    wake_up_interruptible(&cec_rx_struct.waitq);
+	wake_up_interruptible(&cec_rx_struct.waitq);
+    }
 
-    tvout_dbg("amlogic_cec_irq_handler: leave\n");
+    amlogic_cec_log_dbg("amlogic_cec_irq_handler: leave\n");
 
     return IRQ_HANDLED;
 }
@@ -414,10 +522,12 @@ static void amlogic_cec_delayed_init(struct work_struct *work)
 {
     hdmitx_dev_t* hdmitx_device = (hdmitx_dev_t*)container_of(work, hdmitx_dev_t, cec_work);
 
-    tvout_dbg("amlogic_cec_delayed_init: enter\n");
+    amlogic_cec_log_dbg("amlogic_cec_delayed_init: enter\n");
 
     msleep_interruptible(15000);
 
+    cec_init_flag = 1;
+
 #if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
     cec_gpi_init();
 #endif
@@ -446,10 +556,12 @@ static void amlogic_cec_delayed_init(struct work_struct *work)
     cec_arbit_bit_time_set(7, 0x2aa, 0);
 #endif
 
+    cec_init_flag = 0;
+
     hdmitx_device->cec_init_ready = 1;
-    cec_global_info.cec_flag.cec_init_flag = 0;
+    wake_up_interruptible(&cec_tx_struct.waitq);
 
-    tvout_dbg("amlogic_cec_delayed_init: leave\n");
+    amlogic_cec_log_dbg("amlogic_cec_delayed_init: leave\n");
 }
 
 static int amlogic_cec_init(void)
@@ -460,22 +572,17 @@ static int amlogic_cec_init(void)
     printk(banner);
 
     hdmitx_device = get_hdmitx_device();
-    tvout_dbg("CEC init\n");
-    memset(&cec_global_info, 0, sizeof(cec_global_info_t));
-
+    amlogic_cec_log_dbg("CEC init\n");
 #if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
     hdmi_wr_reg(CEC0_BASE_ADDR+CEC_CLOCK_DIV_H, 0x00 );
     hdmi_wr_reg(CEC0_BASE_ADDR+CEC_CLOCK_DIV_L, 0xf0 );
 #endif
 
-    cec_global_info.cec_rx_msg_buf.rx_buf_size = sizeof(cec_global_info.cec_rx_msg_buf.cec_rx_message)/sizeof(cec_global_info.cec_rx_msg_buf.cec_rx_message[0]);
-    cec_global_info.hdmitx_device = hdmitx_device;
-
 #if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
     if (request_irq(INT_HDMI_CEC, &amlogic_cec_irq_handler,
     IRQF_SHARED, "amhdmitx-cec",(void *)hdmitx_device))
     {
-    	tvout_dbg("Can't register IRQ %d\n",INT_HDMI_CEC);
+    	amlogic_cec_log_dbg("Can't register IRQ %d\n",INT_HDMI_CEC);
         return -EFAULT;
     }
 #endif
@@ -483,14 +590,19 @@ static int amlogic_cec_init(void)
     if (request_irq(INT_AO_CEC, &amlogic_cec_irq_handler,
     IRQF_SHARED, "amhdmitx-aocec",(void *)hdmitx_device))
     {
-    	tvout_dbg("Can't register IRQ %d\n",INT_HDMI_CEC);
+    	amlogic_cec_log_dbg("Can't register IRQ %d\n",INT_HDMI_CEC);
         return -EFAULT;
     }
 #endif
 
     init_waitqueue_head(&cec_rx_struct.waitq);
+
     spin_lock_init(&cec_rx_struct.lock);
 
+    init_waitqueue_head(&cec_tx_struct.waitq);
+
+    spin_lock_init(&cec_tx_struct.lock);
+
     if (misc_register(&cec_misc_device))
     {
 	printk(KERN_WARNING " Couldn't register device 10, %d.\n", CEC_MINOR);
@@ -506,14 +618,14 @@ static int amlogic_cec_init(void)
     INIT_WORK(&hdmitx_device->cec_work, amlogic_cec_delayed_init);
     queue_work(cec_workqueue, &hdmitx_device->cec_work);    // for init
 
-    tvout_dbg("hdmitx_device->cec_init_ready:0x%x\n", hdmitx_device->cec_init_ready);
+    amlogic_cec_log_dbg("hdmitx_device->cec_init_ready:0x%x\n", hdmitx_device->cec_init_ready);
 
     return 0;
 }
 
 static void amlogic_cec_exit(void)
 {
-    if (cec_global_info.cec_flag.cec_init_flag == 1)
+    if (cec_init_flag == 1)
     {
 
 #if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
@@ -523,7 +635,7 @@ static void amlogic_cec_exit(void)
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
         free_irq(INT_AO_CEC, (void *)hdmitx_device);
 #endif
-        cec_global_info.cec_flag.cec_init_flag = 0;
+        cec_init_flag = 0;
     }
 
 	misc_deregister(&cec_misc_device);
