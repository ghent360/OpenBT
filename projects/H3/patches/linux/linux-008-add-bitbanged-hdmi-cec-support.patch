diff -Nur a/drivers/video/sunxi/disp2/hdmi/aw/hdmi_cec.c cec_bitbang/drivers/video/sunxi/disp2/hdmi/aw/hdmi_cec.c
--- a/drivers/video/sunxi/disp2/hdmi/aw/hdmi_cec.c	1970-01-01 01:00:00.000000000 +0100
+++ cec_bitbang/drivers/video/sunxi/disp2/hdmi/aw/hdmi_cec.c	2016-03-10 18:48:49.818797351 +0100
@@ -0,0 +1,2110 @@
+#include <linux/netlink.h>
+#include <net/netlink.h>
+#include <linux/socket.h>
+#include <net/sock.h>
+#include <linux/input.h>
+#include <linux/ktime.h>
+
+#include <linux/earlysuspend.h>
+#include <linux/pm_runtime.h>
+#include <linux/device.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/cdev.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <mach/sys_config.h>
+#include <mach/platform.h>
+
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/pinctrl/pinconf-sunxi.h>
+
+#include "hdmi_cec.h"
+
+int debug_mask = 0x00;
+
+/* protect send msg */
+struct mutex mutex_msg_send;
+
+/* socket for hdme cec,comminucate with android */
+struct sock* hdmi_cec_sock = NULL;
+static struct task_struct * cec_task;
+static long unsigned long last_irq_time = 0;
+
+static struct input_dev * hdmicecdev;
+static volatile int receive_a_frame = 0;
+static int hdmi_cec_polling_complete = 0;
+
+typedef struct {
+	__u32 cec_key;
+	__u32 input_key;
+} __disp_cec_key_tab;
+
+static __disp_cec_key_tab cec_key_tab[] = {
+	{0x00, KEY_SELECT},
+	{0x01, KEY_UP},
+	{0x02, KEY_DOWN},
+	{0x03, KEY_LEFT},
+	{0x04, KEY_RIGHT},
+	{0x09, KEY_MENU},
+	{0x11, KEY_CONTEXT_MENU},
+	{0x0D, KEY_BACK},
+	{0x20, KEY_0},
+	{0x21, KEY_1},
+	{0x22, KEY_2},
+	{0x23, KEY_3},
+	{0x24, KEY_4},
+	{0x25, KEY_5},
+	{0x26, KEY_6},
+	{0x27, KEY_7},
+	{0x28, KEY_8},
+	{0x29, KEY_9},
+	{0x2B, KEY_ENTER},
+	{0x30, KEY_CHANNELUP},
+	{0x31, KEY_CHANNELDOWN},
+	{0x35, KEY_INFO},
+	{0x37, KEY_PAGEUP},
+	{0x38, KEY_PAGEDOWN},
+	{0x40, KEY_POWER},
+	{0x41, KEY_VOLUMEUP},
+	{0x42, KEY_VOLUMEDOWN},
+	{0x43, KEY_MUTE},
+	{0x44, KEY_PLAY},
+	{0x45, KEY_STOP},
+	{0x46, KEY_PAUSE},
+	{0x47, KEY_RECORD},
+	{0x48, KEY_REWIND},
+	{0x4A, KEY_EJECTCD},
+	{0x4B, KEY_FORWARD},
+	{0x4C, KEY_REWIND},
+	{0x50, KEY_ANGLE},
+	{0x53, KEY_EPG},
+	{0x71, KEY_BLUE},
+	{0x72, KEY_RED},
+	{0x73, KEY_GREEN},
+	{0x74, KEY_YELLOW},
+};
+
+static unsigned int last_button;
+
+//physical addres
+__u32 hdmi_cec_phy_addr;
+int u_pid;
+
+//gpio
+int hdmi_cec_irqnum = -1;
+__u32 hdmi_cec_gpio;
+__u16 flag = 0;
+int hdmi_cec_used;
+int hdmi_cec_pin;
+
+//extern int hdmi_cec_pin_num;
+int b_hdmi_suspend;
+int hdmi_cec_wakeup_status;
+
+//polling message
+static struct hrtimer hdmi_cec_polling_message_hrtimer;
+ktime_t hdmi_cec_polling_message_kt;
+
+__hdmi_cec_polling_message_data polling_mes_data;
+
+//send frame
+static struct hrtimer hdmi_cec_send_frame_hrtimer;
+ktime_t hdmi_cec_send_frame_kt;
+int irq_num;
+
+__hdmi_cec_send_frame_data send_frame_data;
+__hdmi_cec_send_message send_frame_buffer[10];
+
+//receive frame
+static struct hrtimer hdmi_cec_receive_frame_hrtimer;
+ktime_t hdmi_cec_receive_frame_kt;
+
+__hdmi_cec_receive_frame_data receive_frame_data;
+__hdmi_cec_receive_message receive_frame_buffer[10];
+
+#define TYPE_IN		0
+#define TYPE_OUT	1
+#define TYPE_EINT	6
+static void hdmi_cec_pin_config_type(int gpio, int type)
+{
+	long unsigned int	config;
+	char name[8];
+
+	sunxi_gpio_to_name(gpio, name);
+	config = SUNXI_PINCFG_PACK(SUNXI_PINCFG_TYPE_FUNC, 0xFFFF);
+	pin_config_get(SUNXI_PINCTRL, name, &config);
+
+	if (type != SUNXI_PINCFG_UNPACK_VALUE(config)){
+      config = SUNXI_PINCFG_PACK(SUNXI_PINCFG_TYPE_FUNC, type);
+	  pin_config_set(SUNXI_PINCTRL, name, config);;
+	}
+
+	if (type == TYPE_IN) {
+		config = SUNXI_PINCFG_PACK(SUNXI_PINCFG_TYPE_PUD, 0xFFFF);
+		pin_config_get(SUNXI_PINCTRL, name, &config);
+
+      	config = SUNXI_PINCFG_PACK(SUNXI_PINCFG_TYPE_PUD, 0x01);
+	  	pin_config_set(SUNXI_PINCTRL, name, config);;
+	}
+}
+
+static void hdmi_cec_pin_disable_irq(void)
+{
+	disable_irq_nosync(hdmi_cec_irqnum);
+}
+
+static void hdmi_cec_pin_enable_irq(void)
+{
+	enable_irq(hdmi_cec_irqnum);
+}
+
+static void hdmi_cec_pin_as_eint(int gpio)
+{
+	hdmi_cec_pin_config_type(gpio, TYPE_EINT);
+}
+
+static void hdmi_cec_pin_as_input(int gpio)
+{
+	hdmi_cec_pin_config_type(gpio, TYPE_IN);
+}
+
+static void hdmi_cec_pin_as_output(int gpio)
+{
+	hdmi_cec_pin_config_type(gpio, TYPE_OUT);
+}
+
+__u32 hdmi_cec_read_reg_bit(void)
+{
+
+//	volatile int *data   = (volatile int *)(0xf1c20800 + 0x10);
+//	int reg = *data;
+
+//	reg = reg & (1<<21);
+//	return (reg!=0)?1:0;
+	return __gpio_get_value(hdmi_cec_gpio);
+}
+
+void hdmi_cec_write_reg_bit1(void)
+{
+	__gpio_set_value(hdmi_cec_gpio, 1);
+}
+
+void hdmi_cec_write_reg_bit0(void)
+{
+	__gpio_set_value(hdmi_cec_gpio, 0);
+}
+
+void hdmi_cec_send_info_logical_byte(__u32 data)
+{
+    __u32 offset = send_frame_data.flags /2 - 1;
+    if(send_frame_data.flags %2 == 1) {
+        hdmi_cec_write_reg_bit0();
+
+        if((data >> offset) & 0x1)
+            hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_DATA_BIT_LOGICAL1_LOW_TIME);
+        else
+            hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_DATA_BIT_LOGICAL0_LOW_TIME);
+        } else {
+            hdmi_cec_write_reg_bit1();
+
+            if((data >> offset) & 0x1)
+                hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_DATA_BIT_WHOLE_TIME - HDMI_CEC_DATA_BIT_LOGICAL1_LOW_TIME);
+            else
+                hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_DATA_BIT_WHOLE_TIME - HDMI_CEC_DATA_BIT_LOGICAL0_LOW_TIME);
+            }
+
+    send_frame_data.flags--;
+}
+
+void hdmi_cec_send_eom_logical_bit(void)
+{
+	if(send_frame_data.flags % 2 == 1) {
+        hdmi_cec_write_reg_bit0();
+
+        if(send_frame_data.eom == HDMI_CEC_MSG_EOM_MORE)
+                hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_DATA_BIT_LOGICAL0_LOW_TIME);
+        else
+            hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_DATA_BIT_LOGICAL1_LOW_TIME);
+        } else {
+            hdmi_cec_write_reg_bit1();
+
+            if(send_frame_data.eom == HDMI_CEC_MSG_EOM_MORE)
+                hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_DATA_BIT_WHOLE_TIME - HDMI_CEC_DATA_BIT_LOGICAL0_LOW_TIME);
+            else
+                hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_DATA_BIT_WHOLE_TIME - HDMI_CEC_DATA_BIT_LOGICAL1_LOW_TIME);
+            }
+
+    send_frame_data.flags--;
+}
+
+void hdmi_cec_send_ack_logical_bit(void)
+{
+	if(send_frame_data.flags% 2 == 1) {
+        hdmi_cec_write_reg_bit0();
+        hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_DATA_BIT_LOGICAL1_LOW_TIME);
+        } else {
+
+			hdmi_cec_pin_as_input(hdmi_cec_gpio);
+           // hdmi_cec_write_reg_bit1();
+            hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_DATA_BIT_ACK_INVALID_TIME);
+            }
+    send_frame_data.flags--;
+}
+
+static enum hrtimer_restart hdmi_cec_polling_hrtimer_handler(struct hrtimer *timer)
+{
+	switch(polling_mes_data.sta) {
+        case pre_polling_mes:
+            if(hdmi_cec_read_reg_bit()) {
+                polling_mes_data.status_flags--;
+
+                if(polling_mes_data.status_flags == 0) {
+					hdmi_cec_pin_as_output(hdmi_cec_gpio);
+					hdmi_cec_write_reg_bit0();
+                    polling_mes_data.sta = start_polling_bit;
+                    hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_START_BIT_LOW_TIME);
+                    }
+                } else {
+                    polling_mes_data.status_flags = 30;
+                    }
+            break;
+
+        case start_polling_bit:
+            hdmi_cec_write_reg_bit1();
+            hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_START_BIT_HIGH_TIME);
+            polling_mes_data.sta = polling_mes_set_info_bit;
+            send_frame_data.flags = 17;
+            break;
+
+        case polling_mes_set_info_bit:
+            if(send_frame_data.flags > 1)
+                hdmi_cec_send_info_logical_byte(polling_mes_data.header_block);
+
+            if(send_frame_data.flags == 1) {
+                polling_mes_data.sta = polling_mes_set_eom_bit;
+                send_frame_data.flags = 3;
+                send_frame_data.eom = HDMI_CEC_MSG_EOM_END;
+                }
+            break;
+
+        case polling_mes_set_eom_bit:
+            if(send_frame_data.flags > 1)
+                hdmi_cec_send_eom_logical_bit();
+
+            if(send_frame_data.flags == 1) {
+                polling_mes_data.sta = polling_mes_set_ack_bit;
+                send_frame_data.flags = 3;
+                }
+            break;
+
+        case polling_mes_set_ack_bit:
+            if(send_frame_data.flags > 1)
+                hdmi_cec_send_ack_logical_bit();
+
+            if(send_frame_data.flags == 1) {
+                polling_mes_data.sta = polling_mes_get_ack_bit;
+                }
+
+            if(polling_mes_data.broadcast_flags == 1) {
+                polling_mes_data.broadcast_complete_flags = 1;
+                hdmi_cec_debug("****************polling_mes_data broadcast_complete_flags\n");
+                goto out_complete;
+                }
+            break;
+
+        case polling_mes_get_ack_bit:
+			hdmi_cec_pin_as_input(hdmi_cec_gpio);
+            if(hdmi_cec_read_reg_bit()) {
+                send_frame_data.indicate_logical_adr = polling_mes_data.header_block & 0xf;
+                polling_mes_data.broadcast_flags = 1;
+                polling_mes_data.sta = complete_polling_mes;
+         	} else {
+          		polling_mes_data.sta = continue_polling_mes;
+              	hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_CONFIRM_LOGICAL_BIT_TIME);
+
+              	send_frame_data.resend_flags--;
+			}
+			hdmi_cec_pin_as_output(hdmi_cec_gpio);
+			hdmi_cec_write_reg_bit1();
+            break;
+
+        case continue_polling_mes:
+            if(send_frame_data.resend_flags == 0) {
+                if((polling_mes_data.header_block & 0xf) == HDMI_CEC_LADDR_PLAYER1) {
+                    polling_mes_data.header_block  = (HDMI_CEC_LADDR_PLAYER2 << 4) |HDMI_CEC_LADDR_PLAYER2;
+                    send_frame_data.resend_flags = 5;
+                    } else if((polling_mes_data.header_block & 0xf) == HDMI_CEC_LADDR_PLAYER2) {
+                        polling_mes_data.header_block  = (HDMI_CEC_LADDR_PLAYER3 << 4) | HDMI_CEC_LADDR_PLAYER3;
+                        send_frame_data.resend_flags = 5;
+                        } else {
+                            goto out_failed;
+                            }
+                }
+
+            polling_mes_data.sta = pre_polling_mes;
+            polling_mes_data.status_flags = 30;
+			hdmi_cec_pin_as_input(hdmi_cec_gpio);
+            hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_PRE_POLLING_MESSAGE_TIME);
+
+            break;
+
+        case complete_polling_mes:
+            polling_mes_data.sta = pre_polling_mes;
+            polling_mes_data.status_flags = 30;
+			hdmi_cec_pin_as_input(hdmi_cec_gpio);
+            hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_PRE_POLLING_MESSAGE_TIME);
+            break;
+
+        default :
+            break;
+        }
+
+    hrtimer_forward_now(timer, hdmi_cec_send_frame_kt);
+    return HRTIMER_RESTART;
+
+    out_failed:
+		hdmi_cec_debug("CEC polling msg failed\n");
+        receive_frame_data.sta = judge_start_bit;
+        hdmi_cec_receive_frame_kt = ktime_set(0, HDMI_CEC_JUDGE_START_BIT_TIME);
+		hdmi_cec_pin_as_eint(hdmi_cec_gpio);
+		hdmi_cec_pin_enable_irq();
+        return HRTIMER_NORESTART;
+
+    out_complete:
+		hdmi_cec_debug("CEC polling msg ok, indicate logical addr: 0x%08x\n",
+			send_frame_data.indicate_logical_adr);
+        receive_frame_data.sta = judge_start_bit;
+        hdmi_cec_receive_frame_kt = ktime_set(0, HDMI_CEC_JUDGE_START_BIT_TIME);
+		hdmi_cec_pin_as_eint(hdmi_cec_gpio);
+		hdmi_cec_pin_enable_irq();
+		hdmi_cec_write_reg_bit1();
+		hdmi_cec_polling_complete = 1;
+
+        return HRTIMER_NORESTART;
+}
+
+void hdmi_cec_polling_message(void)
+{
+    polling_mes_data.broadcast_complete_flags = 0;
+    polling_mes_data.sta = pre_polling_mes;
+    send_frame_data.resend_flags = 5;
+
+    polling_mes_data.status_flags = 30;
+
+    polling_mes_data.broadcast_flags = 0;
+
+	hdmi_cec_pin_disable_irq();
+	hdmi_cec_pin_as_input(hdmi_cec_gpio);
+
+    polling_mes_data.header_block = (HDMI_CEC_LADDR_PLAYER1 << 4) |HDMI_CEC_LADDR_PLAYER1;
+
+    hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_PRE_POLLING_MESSAGE_TIME);
+    hrtimer_start(&hdmi_cec_polling_message_hrtimer, hdmi_cec_send_frame_kt, HRTIMER_MODE_REL);
+}
+
+void hdmi_cec_clear_polling_flags(void)
+{
+    polling_mes_data.broadcast_complete_flags = 0;
+}
+
+int __disp_set_cec_active_source(void)
+{
+	unsigned int phy_addr;
+	__hdmi_cec_send_message mes;
+
+	memset(mes.oprands, 0, 14 * sizeof(unsigned long));
+	phy_addr = hdmi_cec_phy_addr;
+	mes.follower_adr = HDMI_CEC_LADDR_BROADCAST;
+	mes.opcode = HDMI_CEC_ACTIVE_SOURCE;
+	mes.oprands_num = 2;
+	mes.oprands[0] = (phy_addr >> 8) & 0xff;
+	mes.oprands[1] = phy_addr & 0xff;
+	hdmi_send_message(&mes);
+
+    return 0;
+}
+
+int __disp_set_cec_inactive_source(void)
+{
+    uint32_t phy_addr;
+	__hdmi_cec_send_message mes;
+	phy_addr = hdmi_cec_phy_addr;
+	mes.oprands_num = 2;
+	mes.opcode_flags = 1;
+	mes.follower_adr = HDMI_CEC_LADDR_TV;
+	mes.opcode = HDMI_CEC_INACTIVE_SOURCE;
+	memset(mes.oprands, 0, 14 * sizeof(unsigned long));
+	mes.oprands[0] = (phy_addr >> 8) & 0xff;
+	mes.oprands[1] = phy_addr & 0xff;
+	hdmi_send_message(&mes);
+
+    return 0;
+}
+
+int __disp_set_cec_request_active_source(void)
+{
+	__hdmi_cec_send_message mes;
+	mes.oprands_num = 0;
+	mes.opcode_flags = 1;
+	mes.follower_adr = HDMI_CEC_LADDR_BROADCAST;
+	mes.opcode = HDMI_CEC_REQUEST_ACTIVE_SOURCE;
+	memset(mes.oprands, 0, 14 * sizeof(unsigned long));
+	mes.oprands[0] = 0;
+	hdmi_send_message(&mes);
+    return 0;
+}
+
+int __disp_set_standby_to_tv(void)
+{
+	__hdmi_cec_send_message mes;
+	mes.oprands_num = 0;
+	mes.opcode_flags = 1;
+	mes.follower_adr = HDMI_CEC_LADDR_BROADCAST;
+	mes.opcode = HDMI_CEC_STANDBY;
+	memset(mes.oprands, 0, 14 * sizeof(unsigned long));
+	mes.oprands[0] = 0;
+	hdmi_send_message(&mes);
+    return 0;
+}
+
+int __disp_set_cec_dev_physical_addr_to_tv(void)
+{
+	unsigned int phy_addr;
+    __hdmi_cec_send_message mes;
+	mes.oprands_num = 3;
+	mes.opcode_flags = 1;
+	mes.follower_adr = HDMI_CEC_LADDR_BROADCAST;
+	mes.opcode = HDMI_CEC_REPORT_PHY_ADDR;
+	memset(mes.oprands, 0, 14 * sizeof(unsigned long));
+	phy_addr = hdmi_cec_phy_addr;
+	mes.oprands[0] = (phy_addr >> 8) & 0xff;
+	mes.oprands[1] = phy_addr & 0xff;
+	mes.oprands[2] = 0x4;
+	hdmi_send_message(&mes);
+
+    return 0;
+}
+
+int __disp_set_cec_send_vendor_id(void)
+{
+	__hdmi_cec_send_message mes;
+
+	mes.oprands_num = 2;
+	mes.opcode_flags = 1;
+	mes.follower_adr = HDMI_CEC_LADDR_BROADCAST;
+	mes.opcode = HDMI_CEC_SENT_VERDOR_ID;
+	memset(mes.oprands, 0, 14 * sizeof(unsigned long));
+	mes.oprands[0] = (0x238 >> 8) & 0xff;
+	mes.oprands[1] = 0x238 & 0xff;
+
+/*
+	mes.oprands_num = 7;
+	mes.opcode_flags = 1;
+	mes.follower_adr = HDMI_CEC_LADDR_BROADCAST;
+	mes.opcode = HDMI_CEC_SENT_VERDOR_ID;
+	memset(mes.oprands, 0, 14 * sizeof(unsigned long));
+	mes.oprands[0] = 7;
+	mes.oprands[1] = 0;
+	mes.oprands[2] = 46;
+	mes.oprands[3] = 0;
+	mes.oprands[4] = 5;
+	mes.oprands[5] = 0;
+	mes.oprands[6] = 2;
+*/
+	hdmi_send_message(&mes);
+
+    return 0;
+}
+
+int __disp_set_cec_power_status_to_tv(void)
+{
+	__hdmi_cec_send_message mes;
+	mes.oprands_num = 1;
+	mes.opcode_flags = 1;
+	mes.follower_adr = HDMI_CEC_LADDR_TV;
+	mes.opcode = HDMI_CEC_REPORT_POWER_STATUS;
+	memset(mes.oprands, 0, 14 * sizeof(unsigned long));
+	mes.oprands[0] = (b_hdmi_suspend == 0)?0:1;
+	hdmi_send_message(&mes);
+
+	return 0;
+}
+
+int __disp_set_cec_image_view_on(void)
+{
+	__hdmi_cec_send_message mes;
+	mes.oprands_num = 0;
+	mes.opcode_flags = 1;
+	mes.follower_adr = HDMI_CEC_LADDR_TV;
+	mes.opcode = HDMI_CEC_IMAGE_VIEW_ON;
+	memset(mes.oprands, 0, 14 * sizeof(unsigned long));
+	hdmi_send_message(&mes);
+
+	return 0;
+}
+
+int __disp_set_cec_osd_name(void)
+{
+    int i,name_size;
+    char *p_osd_n = HDMI_CEC_OSD_NAME;
+	__hdmi_cec_send_message mes;
+
+	name_size = strlen(p_osd_n);
+	if (name_size > 14){
+          pr_warning("####the size of name is too long,and get 14 letters.\n");
+          name_size = 14;
+    }
+	mes.oprands_num = name_size;
+	mes.opcode_flags = 1;
+	mes.follower_adr = HDMI_CEC_LADDR_TV;
+	mes.opcode = HDMI_CEC_SET_OSD_NAME;
+	memset(mes.oprands, 0, 14 * sizeof(unsigned long));
+	for (i = 0 ; i < name_size; i++)
+         mes.oprands[i] = p_osd_n[i];//*(p_osd_n + i);
+	hdmi_send_message(&mes);
+
+	return 0;
+}
+
+int __disp_set_cec_text_view_on(void)
+{
+	__hdmi_cec_send_message mes;
+	mes.oprands_num = 0;
+	mes.opcode_flags = 1;
+	mes.follower_adr = HDMI_CEC_LADDR_TV;
+	mes.opcode = HDMI_CEC_TEXT_VIEW_ON;
+	memset(mes.oprands, 0, 14 * sizeof(unsigned long));
+	hdmi_send_message(&mes);
+
+	return 0;
+}
+
+static void __disp_cec_receive_tv_standby(void)
+{
+	input_report_key(hdmicecdev, KEY_POWER, 1);
+	input_sync(hdmicecdev);
+ 	msleep(100);
+	input_report_key(hdmicecdev, KEY_POWER, 0);
+	input_sync(hdmicecdev);
+}
+
+int __disp_set_cec_version_to_tv(void)
+{
+	__hdmi_cec_send_message mes;
+	mes.oprands_num = 1;
+	mes.opcode_flags = 1;
+	mes.follower_adr = HDMI_CEC_LADDR_TV;
+	mes.opcode = HDMI_CEC_REPORT_CEC_VERSION;
+	memset(mes.oprands, 0, 14 * sizeof(unsigned long));
+	mes.oprands[0] = 0x03; //Version 1.3
+	hdmi_send_message(&mes);
+
+	return 0;
+}
+
+int __disp_set_cec_menu_status_to_tv(void)
+{
+	__hdmi_cec_send_message mes;
+	mes.oprands_num = 1;
+	mes.opcode_flags = 1;
+	mes.follower_adr = HDMI_CEC_LADDR_TV;
+	mes.opcode = HDMI_CEC_MENU_STATE;
+	memset(mes.oprands, 0, 14 * sizeof(unsigned long));
+	/* Activated: 0, Deactivated:1 */
+	mes.oprands[0] = (b_hdmi_suspend == 0)?0:1;;
+	hdmi_send_message(&mes);
+
+	return 0;
+}
+
+int __disp_get_menu_language(void)
+{
+	__hdmi_cec_send_message mes;
+	mes.oprands_num = 0;
+	mes.opcode_flags = 1;
+	mes.follower_adr = HDMI_CEC_LADDR_TV;
+	mes.opcode = HDMI_CEC_GET_MENU_LANGUAGE;
+	memset(mes.oprands, 0, 14 * sizeof(unsigned long));
+	hdmi_send_message(&mes);
+
+	return 0;
+}
+
+int __disp_set_cec_send_routing_inf_to_tv(void)
+{
+	uint32_t phy_addr;
+    __hdmi_cec_send_message mes;
+	mes.oprands_num = 2;
+	mes.opcode_flags = 1;
+	mes.follower_adr = HDMI_CEC_LADDR_BROADCAST;
+	mes.opcode = HDMI_CEC_SENT_ROUTING_INFORMATION;
+	memset(mes.oprands, 0, 14 * sizeof(unsigned long));
+	phy_addr = hdmi_cec_phy_addr;
+	mes.oprands[0] = (phy_addr >> 8) & 0xff;
+	mes.oprands[1] = phy_addr & 0xff;
+	hdmi_send_message(&mes);
+
+    return 0;
+}
+
+int __disp_set_cec_hdmi_ch(void)
+{
+    __hdmi_cec_send_message mes;
+	mes.follower_adr = HDMI_CEC_LADDR_BROADCAST;
+	mes.opcode = HDMI_CEC_ACTIVE_SOURCE;
+	mes.oprands_num = 2;
+	mes.opcode_flags = 1;
+	memset(mes.oprands, 0, 14 * sizeof(unsigned long));
+	mes.oprands[0] = (hdmi_cec_phy_addr >> 8) & 0xff;
+	mes.oprands[1] = hdmi_cec_phy_addr & 0xff;
+	hdmi_send_message(&mes);
+    return 0;
+}
+
+int __disp_get_routing_change(__hdmi_cec_receive_message *process_data)
+{
+	if(process_data->oprands_num == 4)
+	{
+		unsigned int original_addr, new_addr;
+		original_addr = ((process_data->oprands[0] & 0xff) << 8) | (process_data->oprands[1] & 0xff);
+		new_addr = ((process_data->oprands[2] & 0xff) << 8) | (process_data->oprands[3] & 0xff);
+		//printk("original phy addr = 0x%x, new phy addr = 0x%x", original_addr, new_addr);
+		if(hdmi_cec_phy_addr == new_addr)
+		{
+			__disp_set_cec_send_routing_inf_to_tv();
+		}
+		else if (hdmi_cec_phy_addr == original_addr)
+		{
+			hdmi_cec_phy_addr = new_addr;
+			__disp_set_cec_dev_physical_addr_to_tv();
+			__disp_set_cec_active_source();
+		}
+	}
+
+	return 0;
+}
+
+int __disp_set_cec_stream_path(__hdmi_cec_receive_message *process_data)
+{
+	unsigned int phy_addr;
+
+	if(process_data->oprands_num == 2)
+	{
+		phy_addr = ((process_data->oprands[0] & 0xff) << 8) | (process_data->oprands[1] & 0xff);
+		if(hdmi_cec_phy_addr != phy_addr)
+		{
+			hdmi_cec_phy_addr = phy_addr;
+			//printk("cec stream path change, hdmi_cec_phy_addr = 0x%x\n", hdmi_cec_phy_addr);
+		}
+		if(b_hdmi_suspend == 1)
+		{
+			__disp_cec_receive_tv_standby();
+			//printk("cec stream path change, set system standby 0\n");
+		}
+		__disp_set_cec_active_source();
+	}
+
+	return 0;
+}
+
+int __disp_cec_receive_user_control(__hdmi_cec_receive_message *process_data)
+{
+	if(process_data->opcode == 0x44)
+	{
+		int i;
+		for(i=0; i < sizeof(cec_key_tab)/sizeof(__disp_cec_key_tab); i++)
+		{
+			if(cec_key_tab[i].cec_key == process_data->oprands[0])
+			{
+				//printk("key = %d press\n", cec_key_tab[i].input_key);
+				input_report_key(hdmicecdev, cec_key_tab[i].input_key, 1);
+				input_sync(hdmicecdev);
+				last_button = cec_key_tab[i].input_key;
+			}
+		}
+	}
+	else
+	{
+		//printk("key: %d release\n", last_button);
+		input_report_key(hdmicecdev, last_button, 0);
+		input_sync(hdmicecdev);
+	}
+
+	return 0;
+}
+
+int __disp_cec_receive_tv_language_report(__hdmi_cec_receive_message *process_data)
+{
+	hdmi_cec_debug("tv menu language{%d}: %02x%02x%02x\n",
+		process_data->oprands_num,
+		process_data->oprands[0],
+		process_data->oprands[1],
+		process_data->oprands[2]);
+
+	return 0;
+}
+
+static void hdmi_cec_prepare(void)
+{
+	hdmi_cec_polling_complete = 0;
+	mdelay(20);
+	__disp_set_cec_dev_physical_addr_to_tv();
+	mdelay(20);
+	__disp_set_cec_image_view_on();
+	mdelay(20);
+	__disp_get_menu_language();
+	mdelay(20);
+	__disp_set_cec_active_source();
+	mdelay(20);
+	__disp_set_cec_menu_status_to_tv();
+	mdelay(20);
+	__disp_set_cec_osd_name();
+	mdelay(20);
+}
+
+static void __disp_cec_data_process(__hdmi_cec_receive_message *process_data)
+{
+	hdmi_cec_debug("+ process 0x%02x\n", process_data->opcode);
+
+#if 0
+	if(hdmi_cec_polling_complete == 1)
+	{
+		//printk("hdmi_cec_polling_complete = 1, set serial operation\n");
+		pr_info("++ send cmd to tv\n");
+		hdmi_cec_polling_complete = 0;
+		mdelay(20);
+		pr_info("++ set phy addr\n");
+		__disp_set_cec_dev_physical_addr_to_tv();
+		mdelay(20);
+		pr_info("++ image view on\n");
+		__disp_set_cec_image_view_on();
+		mdelay(20);
+		pr_info("++ get menu lan\n");
+		__disp_get_menu_language();
+		mdelay(20);
+		pr_info("++ active source\n");
+		__disp_set_cec_active_source();
+		mdelay(20);
+		pr_info("++ set menu status\n");
+		__disp_set_cec_menu_status_to_tv();
+		mdelay(20);
+		pr_info("++ set cec osd name\n");
+		__disp_set_cec_osd_name();
+		mdelay(20);
+		pr_info("++ set standby\n");
+		__disp_set_cec_power_status_to_tv();
+		mdelay(20);
+	}
+#endif
+
+	switch(process_data->opcode)
+	{
+		/* Report OSD name */
+		case 0x46:
+			//mdelay(20);
+			__disp_set_cec_osd_name();
+			break;
+
+		/* Get Routing Change */
+		case 0x80:
+			__disp_get_routing_change(process_data);
+			break;
+
+		/* Report Physical Address */
+		case 0x83:
+			//mdelay(20);
+			__disp_set_cec_dev_physical_addr_to_tv();
+			break;
+
+		/* set active source */
+		case 0x85:
+			__disp_set_cec_active_source();
+			break;
+
+		/* Set stream path  */
+		case 0x86:
+			__disp_set_cec_stream_path(process_data);
+			break;
+
+		/* Report vendor ID */
+		case 0x8c:
+			//mdelay(20);
+			__disp_set_cec_send_vendor_id();
+			break;
+
+		/* Report power status */
+		case 0x8f:
+			__disp_set_cec_power_status_to_tv();
+			break;
+
+		/* report CEC Version*/
+		case 0x9f:
+			__disp_set_cec_version_to_tv();
+			break;
+
+		case 0x8d:
+			printk("get tv Menu Request\n");
+			break;
+
+		case 0x44:
+		case 0x45:
+			__disp_cec_receive_user_control(process_data);
+			break;
+
+		case 0x36:
+			__disp_cec_receive_tv_standby();
+			printk("cec receive tv standby\n");
+			break;
+		case 0x32:
+			__disp_cec_receive_tv_language_report(process_data);
+			break;
+		default:
+			printk("unknown command: 0x%x, need deal with?\n", process_data->opcode);
+	}
+}
+
+//hrtimer interrupt
+static enum hrtimer_restart hdmi_cec_send_frame_hrtimer_handler(struct hrtimer *timer)
+{
+	switch(send_frame_data.sta) {
+    case pre_send_mes:
+        if(hdmi_cec_read_reg_bit()) {
+        send_frame_data.status_flags--;
+
+        if(send_frame_data.status_flags == 0) {
+			/* TODO set as output */
+            //sw_gpio_setcfg(hdmi_cec_gpio, 1);
+			hdmi_cec_pin_as_output(hdmi_cec_gpio);
+            hdmi_cec_write_reg_bit0();
+            send_frame_data.sta = start_bit;
+            hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_START_BIT_LOW_TIME);
+            }
+        } else {
+                send_frame_data.status_flags = 30;
+                }
+        break;
+
+    case start_bit:
+        if(polling_mes_data.broadcast_complete_flags == 0) {
+            send_frame_data.sta = wait_for_hdmi_connect;
+             hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_WAIT_BROADCAST_COMPLETE);
+             break;
+            }
+
+        if(send_frame_buffer[send_frame_data.current_buf_flags].follower_adr== HDMI_CEC_LADDR_BROADCAST)
+            send_frame_data.ack = HDMI_CEC_MSG_ACK_BROADCAST;
+        else
+            send_frame_data.ack = HDMI_CEC_MSG_ACK_NORMAL;
+
+        hdmi_cec_write_reg_bit1();
+        hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_START_BIT_HIGH_TIME);
+        send_frame_data.sta = header_block_set_info_bit;
+        send_frame_data.flags = 17;
+
+        send_frame_data.oprands_count = 0;
+        break;
+
+    case header_block_set_info_bit:
+        if(polling_mes_data.broadcast_complete_flags == 0) {
+            send_frame_data.sta = wait_for_hdmi_connect;
+             hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_WAIT_BROADCAST_COMPLETE);
+             break;
+            }
+
+        if(send_frame_data.flags > 1)
+            hdmi_cec_send_info_logical_byte((send_frame_data.indicate_logical_adr << 4) | send_frame_buffer[send_frame_data.current_buf_flags].follower_adr);
+
+        if(send_frame_data.flags == 1) {
+            send_frame_data.sta = header_block_set_eom_bit;
+            send_frame_data.flags = 3;
+
+            if(send_frame_buffer[send_frame_data.current_buf_flags].opcode_flags == 1){
+                send_frame_data.eom = HDMI_CEC_MSG_EOM_MORE;
+                send_frame_data.opcode_flags = 1;
+                } else {
+                    send_frame_data.eom = HDMI_CEC_MSG_EOM_END;
+                    send_frame_data.opcode_flags = 0;
+                    }
+            }
+
+        break;
+
+    case header_block_set_eom_bit:
+        if(polling_mes_data.broadcast_complete_flags == 0) {
+            send_frame_data.sta = wait_for_hdmi_connect;
+             hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_WAIT_BROADCAST_COMPLETE);
+             break;
+            }
+
+        if(send_frame_data.flags > 1)
+            hdmi_cec_send_eom_logical_bit();
+
+        if(send_frame_data.flags == 1) {
+            send_frame_data.sta = header_block_set_ack_bit;
+            send_frame_data.flags = 3;
+            }
+
+        break;
+
+    case header_block_set_ack_bit:
+        if(polling_mes_data.broadcast_complete_flags == 0) {
+            send_frame_data.sta = wait_for_hdmi_connect;
+             hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_WAIT_BROADCAST_COMPLETE);
+             break;
+            }
+
+        if(send_frame_data.flags > 1)
+            hdmi_cec_send_ack_logical_bit();
+
+        if(send_frame_data.flags == 1)
+            send_frame_data.sta = header_block_get_ack_bit;
+
+        break;
+
+    case header_block_get_ack_bit:
+        if(polling_mes_data.broadcast_complete_flags == 0) {
+            send_frame_data.sta = wait_for_hdmi_connect;
+             hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_WAIT_BROADCAST_COMPLETE);
+             break;
+            }
+
+		/* TODO set as input */
+        //sw_gpio_setcfg(hdmi_cec_gpio, 0);
+		hdmi_cec_pin_as_input(hdmi_cec_gpio);
+
+        if(((send_frame_data.ack == HDMI_CEC_MSG_ACK_NORMAL) && (hdmi_cec_read_reg_bit() == 1))
+            ||((send_frame_data.ack == HDMI_CEC_MSG_ACK_BROADCAST) && (hdmi_cec_read_reg_bit() == 0)))
+            {
+				hdmi_cec_debug("+eack\n");
+                if(send_frame_data.resend_flags > 0)
+                    {
+                        send_frame_data.sta = continue_send_mes;
+                        send_frame_data.resend_flags--;
+                        break;
+                    }
+            }
+
+        if(send_frame_data.eom == HDMI_CEC_MSG_EOM_MORE) {
+            send_frame_data.sta = opcode_block_set_info_bit;
+            hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_DATA_BIT_ACK_SET_LOW_TIME);
+            send_frame_data.flags = 17;
+            } else {
+                send_frame_data.sta = continue_send_mes;
+                send_frame_data.resend_flags = 5;
+
+                send_frame_data.current_buf_flags++;
+                if(send_frame_data.current_buf_flags > 9)
+                    send_frame_data.current_buf_flags = 0;
+
+                 if(send_frame_data.current_buf_flags == send_frame_data.add_buf_flags)
+                    {
+                        send_frame_data.current_buf_flags = 0;
+                        send_frame_data.add_buf_flags = 0;
+                        goto out_complete;
+                    }
+                }
+
+		/* TODO set as output */
+        //sw_gpio_setcfg(hdmi_cec_gpio, 1);
+		hdmi_cec_pin_as_output(hdmi_cec_gpio);
+		hdmi_cec_write_reg_bit1();
+	//	pr_err("+oack\n");
+        break;
+
+    case opcode_block_set_info_bit:
+        if(polling_mes_data.broadcast_complete_flags == 0) {
+            send_frame_data.sta = wait_for_hdmi_connect;
+             hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_WAIT_BROADCAST_COMPLETE);
+             break;
+            }
+
+        if(send_frame_data.flags > 1)
+            hdmi_cec_send_info_logical_byte(send_frame_buffer[send_frame_data.current_buf_flags].opcode);
+
+        if(send_frame_data.flags == 1) {
+            send_frame_data.sta = opcode_block_set_eom_bit;
+            send_frame_data.flags = 3;
+
+            if(send_frame_buffer[send_frame_data.current_buf_flags].oprands_num == 0) {
+                send_frame_data.eom = HDMI_CEC_MSG_EOM_END;
+                } else {
+                    send_frame_data.eom = HDMI_CEC_MSG_EOM_MORE;
+                    }
+            }
+        break;
+
+    case opcode_block_set_eom_bit:
+        if(polling_mes_data.broadcast_complete_flags == 0) {
+            send_frame_data.sta = wait_for_hdmi_connect;
+             hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_WAIT_BROADCAST_COMPLETE);
+             break;
+            }
+
+        if(send_frame_data.flags > 1)
+            hdmi_cec_send_eom_logical_bit();
+
+        if(send_frame_data.flags == 1) {
+            send_frame_data.sta = opcode_block_set_ack_bit;
+            send_frame_data.flags = 3;
+            }
+
+        break;
+
+    case opcode_block_set_ack_bit:
+        if(polling_mes_data.broadcast_complete_flags == 0) {
+            send_frame_data.sta = wait_for_hdmi_connect;
+             hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_WAIT_BROADCAST_COMPLETE);
+             break;
+            }
+
+        if(send_frame_data.flags > 1)
+            hdmi_cec_send_ack_logical_bit();
+
+        if(send_frame_data.flags == 1)
+            send_frame_data.sta = opcode_block_get_ack_bit;
+
+        break;
+
+    case opcode_block_get_ack_bit:
+        if(polling_mes_data.broadcast_complete_flags == 0) {
+            send_frame_data.sta = wait_for_hdmi_connect;
+             hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_WAIT_BROADCAST_COMPLETE);
+             break;
+            }
+
+		/*TODO set as input */
+        //sw_gpio_setcfg(hdmi_cec_gpio, 0);
+		hdmi_cec_pin_as_input(hdmi_cec_gpio);
+
+        if(((send_frame_data.ack == HDMI_CEC_MSG_ACK_NORMAL) && (hdmi_cec_read_reg_bit() == 1))
+            ||((send_frame_data.ack == HDMI_CEC_MSG_ACK_BROADCAST) && (hdmi_cec_read_reg_bit() == 0)))
+            {
+				hdmi_cec_debug("+dack\n");
+                if(send_frame_data.resend_flags > 0)
+                    {
+                        send_frame_data.sta = continue_send_mes;
+                        send_frame_data.resend_flags--;
+                        break;
+                    }
+            }
+
+		/*TODO set as input */
+        //sw_gpio_setcfg(hdmi_cec_gpio, 1);
+		hdmi_cec_pin_as_output(hdmi_cec_gpio);
+		hdmi_cec_write_reg_bit1();
+
+        if(send_frame_data.eom == HDMI_CEC_MSG_EOM_END) {
+            send_frame_data.sta = continue_send_mes;
+            send_frame_data.resend_flags = 5;
+
+            send_frame_data.current_buf_flags++;
+            if(send_frame_data.current_buf_flags > 9)
+                send_frame_data.current_buf_flags = 0;
+
+             if(send_frame_data.current_buf_flags == send_frame_data.add_buf_flags) {
+                    send_frame_data.current_buf_flags = 0;
+                    send_frame_data.add_buf_flags = 0;
+                    goto out_complete;
+                }
+            } else {
+                send_frame_data.sta = oprands_block_set_info_bit;
+                hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_DATA_BIT_ACK_SET_LOW_TIME);
+                send_frame_data.flags = 17;
+                }
+
+        break;
+
+    case oprands_block_set_info_bit:
+        if(polling_mes_data.broadcast_complete_flags == 0) {
+            send_frame_data.sta = wait_for_hdmi_connect;
+             hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_WAIT_BROADCAST_COMPLETE);
+             break;
+            }
+
+        if(send_frame_data.flags > 1)
+            hdmi_cec_send_info_logical_byte(send_frame_buffer[send_frame_data.current_buf_flags].oprands[send_frame_data.oprands_count]);
+
+        if(send_frame_data.flags == 1) {
+            send_frame_data.sta = oprands_block_set_eom_bit;
+            send_frame_data.flags = 3;
+
+            send_frame_data.oprands_count++;
+
+            if(send_frame_data.oprands_count < send_frame_buffer[send_frame_data.current_buf_flags].oprands_num)
+                send_frame_data.eom = HDMI_CEC_MSG_EOM_MORE;
+            else
+                send_frame_data.eom = HDMI_CEC_MSG_EOM_END;
+            }
+
+        break;
+
+    case oprands_block_set_eom_bit:
+        if(polling_mes_data.broadcast_complete_flags == 0) {
+            send_frame_data.sta = wait_for_hdmi_connect;
+             hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_WAIT_BROADCAST_COMPLETE);
+             break;
+            }
+
+        if(send_frame_data.flags > 1)
+            hdmi_cec_send_eom_logical_bit();
+
+        if(send_frame_data.flags == 1) {
+            send_frame_data.sta = oprands_block_set_ack_bit;
+            send_frame_data.flags = 3;
+            }
+
+        break;
+
+    case oprands_block_set_ack_bit:
+        if(polling_mes_data.broadcast_complete_flags == 0) {
+            send_frame_data.sta = wait_for_hdmi_connect;
+             hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_WAIT_BROADCAST_COMPLETE);
+             break;
+            }
+
+        if(send_frame_data.flags > 1)
+            hdmi_cec_send_ack_logical_bit();
+
+        if(send_frame_data.flags == 1)
+            send_frame_data.sta = oprands_block_get_ack_bit;
+
+        break;
+
+    case oprands_block_get_ack_bit:
+        if(polling_mes_data.broadcast_complete_flags == 0) {
+            send_frame_data.sta = wait_for_hdmi_connect;
+             hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_WAIT_BROADCAST_COMPLETE);
+             break;
+            }
+
+		/*TODO set as input */
+        //sw_gpio_setcfg(hdmi_cec_gpio, 0);
+		hdmi_cec_pin_as_input(hdmi_cec_gpio);
+
+        if(((send_frame_data.ack == HDMI_CEC_MSG_ACK_NORMAL) && (hdmi_cec_read_reg_bit() == 1))
+            ||((send_frame_data.ack == HDMI_CEC_MSG_ACK_BROADCAST) && (hdmi_cec_read_reg_bit() == 0)))
+            {
+                if(send_frame_data.resend_flags > 0)
+                    {
+                        send_frame_data.sta = continue_send_mes;
+                        send_frame_data.resend_flags--;
+                        break;
+                    }
+            }
+
+		/*TODO set as input */
+        //sw_gpio_setcfg(hdmi_cec_gpio, 1);
+		hdmi_cec_pin_as_output(hdmi_cec_gpio);
+		hdmi_cec_write_reg_bit1();
+
+        if(send_frame_data.eom == HDMI_CEC_MSG_EOM_MORE) {
+            send_frame_data.sta = oprands_block_set_info_bit;
+            send_frame_data.flags = 17;
+            hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_DATA_BIT_ACK_SET_LOW_TIME);
+            } else {
+                send_frame_data.sta = continue_send_mes;
+                send_frame_data.resend_flags = 5;
+
+                send_frame_data.current_buf_flags++;
+                if(send_frame_data.current_buf_flags > 9)
+                    send_frame_data.current_buf_flags = 0;
+
+                 if(send_frame_data.current_buf_flags == send_frame_data.add_buf_flags) {
+                        send_frame_data.current_buf_flags = 0;
+                        send_frame_data.add_buf_flags = 0;
+                        goto out_complete;
+                    }
+                }
+
+        break;
+
+    case wait_for_hdmi_connect:
+        if(polling_mes_data.broadcast_complete_flags == 1) {
+            send_frame_data.sta = pre_send_mes;
+            send_frame_data.oprands_count = 0;
+            send_frame_data.status_flags = 30;
+
+            send_frame_data.resend_flags = 5;
+
+			/*TODO set as input */
+            //sw_gpio_setcfg(hdmi_cec_gpio, 0);
+			hdmi_cec_pin_as_input(hdmi_cec_gpio);
+            }
+        break;
+
+    case continue_send_mes:
+        send_frame_data.sta = pre_send_mes;
+        send_frame_data.oprands_count= 0;
+        send_frame_data.status_flags = 30;
+        hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_PRE_SEND_MESSAGE_TIME);
+        send_frame_data.eom = HDMI_CEC_MSG_EOM_MORE;
+		/*TODO set as input */
+        //sw_gpio_setcfg(hdmi_cec_gpio, 0);
+		hdmi_cec_pin_as_input(hdmi_cec_gpio);
+        break;
+
+    default:
+        break;
+        }
+
+    hrtimer_forward_now(timer, hdmi_cec_send_frame_kt);
+    return HRTIMER_RESTART;
+
+    out_complete:
+	hdmi_cec_debug("++ send msg ok\n");
+    receive_frame_data.sta = judge_start_bit;
+    hdmi_cec_receive_frame_kt = ktime_set(0, HDMI_CEC_JUDGE_START_BIT_TIME);
+	/*TODO set as input */
+	//sw_gpio_setcfg(hdmi_cec_gpio, 6);
+    //sw_gpio_eint_set_enable(hdmi_cec_gpio, 1);
+	hdmi_cec_pin_as_eint(hdmi_cec_gpio);
+	hdmi_cec_pin_enable_irq();
+	mutex_unlock(&mutex_msg_send);
+    return HRTIMER_NORESTART;
+}
+
+//start send frame
+__u32 hdmi_cec_start_send_frame(void)
+{
+    if(polling_mes_data.broadcast_complete_flags == 1) {
+        send_frame_data.sta = pre_send_mes;
+        send_frame_data.oprands_count = 0;
+        send_frame_data.oprands_num = send_frame_buffer[send_frame_data.current_buf_flags].oprands_num;
+
+        send_frame_data.status_flags = 30;
+
+        send_frame_data.resend_flags = 5;
+		/*TODO set as input */
+        //sw_gpio_eint_set_enable(hdmi_cec_gpio, 0);
+        //sw_gpio_setcfg(hdmi_cec_gpio, 0);
+		hdmi_cec_pin_disable_irq();
+		hdmi_cec_pin_as_input(hdmi_cec_gpio);
+
+        send_frame_data.eom = HDMI_CEC_MSG_EOM_MORE;
+
+        hdmi_cec_send_frame_kt = ktime_set(0, HDMI_CEC_PRE_SEND_MESSAGE_TIME);
+
+        hrtimer_start(&hdmi_cec_send_frame_hrtimer, hdmi_cec_send_frame_kt, HRTIMER_MODE_REL);
+        }
+    return 0;
+}
+
+void hdmi_send_message(__hdmi_cec_send_message *mes)
+{
+    int i;
+
+    if(hdmi_cec_used && polling_mes_data.broadcast_complete_flags == 1){
+		mutex_lock(&mutex_msg_send);
+		#if 0
+		__Cinf("###opcode = 0x%x,oprands_num = %d\n",mes->opcode, mes->oprands_num);
+	    __Cinf("###follower_adr = %d,opcode_flag = %d\n",mes->follower_adr, mes->opcode_flags);
+		__Cinf("###oprands[0] = %d,oprands[1] = %d\n",mes->oprands[0], mes->oprands[1]);
+		#endif
+
+        send_frame_buffer[send_frame_data.add_buf_flags].opcode_flags= mes->opcode_flags;
+        send_frame_buffer[send_frame_data.add_buf_flags].follower_adr= (mes->follower_adr) & 0xf;
+        send_frame_buffer[send_frame_data.add_buf_flags].oprands_num = mes->oprands_num;
+
+        if(mes->opcode_flags) {
+            send_frame_buffer[send_frame_data.add_buf_flags].opcode = (mes->opcode) & 0xff;
+            for(i = 0; i < mes->oprands_num; i++)
+                send_frame_buffer[send_frame_data.add_buf_flags].oprands[i] = (mes->oprands[i]) & 0xff;
+            }
+
+        if ((send_frame_data.current_buf_flags == 0) && (send_frame_data.add_buf_flags == 0)) {
+			int i;
+			for (i = 0; i < 20; i++) {
+				if (receive_frame_data.sta < header_block_receive_info_bit) {
+
+					hdmi_cec_start_send_frame();
+
+        			send_frame_data.add_buf_flags++;
+					if(send_frame_data.add_buf_flags > 9)
+						send_frame_data.add_buf_flags = 0;
+
+					break;
+				} else {
+					mutex_unlock(&mutex_msg_send);
+					hdmi_cec_debug("CEC pin busy, wait 5ms\n");
+					mdelay(5);
+				}
+			}
+		}
+	}
+}
+
+//receive frame function
+void hdmi_cec_receive_info_logical_byte(void)
+{
+    receive_frame_data.receive_frame = (receive_frame_data.receive_frame |hdmi_cec_read_reg_bit());
+
+    if(receive_frame_data.flags > 1)
+        receive_frame_data.receive_frame = receive_frame_data.receive_frame << 1;
+
+    receive_frame_data.flags--;
+}
+
+//receive frame high resolution timer handler
+static __hdmi_cec_receive_message tmpmsg;
+static enum hrtimer_restart hdmi_cec_receive_frame_hrtimer_handler(struct hrtimer *timer)
+{
+	switch(receive_frame_data.sta) {
+    case judge_start_bit:
+        break;
+
+    case confirm_start_bit:
+        if(hdmi_cec_read_reg_bit() == 1) {
+            receive_frame_data.sta = header_block_receive_info_bit;
+            hdmi_cec_receive_frame_kt = ktime_set(0, HDMI_CEC_CONFIRM_LOGICAL_BIT_TIME);
+            receive_frame_data.flags = 8;
+            receive_frame_data.receive_frame = 0x0;
+
+            receive_frame_data.oprands_count= 0;
+            } else {
+                receive_frame_data.sta = judge_start_bit;
+                hdmi_cec_receive_frame_kt = ktime_set(0, HDMI_CEC_JUDGE_START_BIT_TIME);
+                receive_frame_data.receive_frame = 0x0;
+                }
+
+        break;
+
+    case header_block_receive_info_bit:
+        if(receive_frame_data.flags > 0)
+            hdmi_cec_receive_info_logical_byte();
+
+        if(receive_frame_data.flags == 0) {
+            receive_frame_data.header_block = receive_frame_data.receive_frame;
+
+            if(((receive_frame_data.header_block & 0xf) == send_frame_data.indicate_logical_adr) ||
+                ((receive_frame_data.header_block & 0xf) == HDMI_CEC_LADDR_BROADCAST)) {
+                receive_frame_data.sta = header_block_receive_eom_bit;
+                receive_frame_data.receive_frame = 0x0;
+                } else {
+                    receive_frame_data.sta = judge_start_bit;
+                    //hdmi_cec_receive_frame_kt = ktime_set(0, HDMI_CEC_JUDGE_START_BIT_TIME);
+               	}
+            }
+        break;
+
+    case header_block_receive_eom_bit:
+        if(hdmi_cec_read_reg_bit() == 0) {
+            receive_frame_data.eom = HDMI_CEC_MSG_EOM_MORE;
+
+            receive_frame_data.opcode_flags = 1;
+            } else {
+                receive_frame_data.eom = HDMI_CEC_MSG_EOM_END;
+                }
+
+        receive_frame_data.sta = header_block_ack_bit_pull_down;
+        hdmi_cec_receive_frame_kt = ktime_set(0, HDMI_CEC_PULL_LOW_TIME);
+
+        break;
+
+    case header_block_ack_bit_pull_down:
+        if((receive_frame_data.header_block & 0xf) == send_frame_data.indicate_logical_adr) {
+			/*TODO set as input */
+            //sw_gpio_eint_set_enable(hdmi_cec_gpio, 0);
+            //sw_gpio_setcfg(hdmi_cec_gpio, 1);
+			hdmi_cec_pin_disable_irq();
+			hdmi_cec_pin_as_output(hdmi_cec_gpio);
+            hdmi_cec_write_reg_bit0();
+            }
+
+        receive_frame_data.sta = header_block_ack_bit_pull_up;
+        hdmi_cec_receive_frame_kt = ktime_set(0,  HDMI_CEC_DATA_BIT_LOGICAL0_LOW_TIME - HDMI_CEC_PULL_LOW_TIME);
+        goto out_hrtimer_restart;
+
+        break;
+
+    case header_block_ack_bit_pull_up:
+        if((receive_frame_data.header_block & 0xf) == send_frame_data.indicate_logical_adr) {
+            hdmi_cec_write_reg_bit1();
+			/*TODO set as input */
+            //sw_gpio_setcfg(hdmi_cec_gpio, 6);
+            //sw_gpio_eint_set_enable(hdmi_cec_gpio, 1);
+			hdmi_cec_pin_as_eint(hdmi_cec_gpio);
+			hdmi_cec_pin_enable_irq();
+            }
+
+        if(receive_frame_data.eom == HDMI_CEC_MSG_EOM_MORE) {
+            receive_frame_data.sta = data_block_receive_info_bit;
+            hdmi_cec_receive_frame_kt = ktime_set(0, HDMI_CEC_CONFIRM_LOGICAL_BIT_TIME);
+            receive_frame_data.flags = 8;
+            receive_frame_data.oprands_count= 0;
+            receive_frame_data.receive_frame = 0x0;
+            } else {
+                receive_frame_data.sta = judge_start_bit;
+                //hdmi_cec_receive_frame_kt = ktime_set(0, HDMI_CEC_JUDGE_START_BIT_TIME);
+                }
+
+        break;
+
+    case data_block_receive_info_bit:
+        if(receive_frame_data.flags > 0)
+            hdmi_cec_receive_info_logical_byte();
+
+		if (receive_frame_data.flags == 0) {
+			if (receive_frame_data.opcode_flags == 1) {
+				tmpmsg.opcode = receive_frame_data.receive_frame;
+				receive_frame_data.opcode_flags = 0;
+//				printk("r %02x %02x\n",receive_frame_data.header_block, tmpmsg.opcode);
+			} else {
+				tmpmsg.oprands[receive_frame_data.oprands_count] = receive_frame_data.receive_frame;
+				receive_frame_data.oprands_count++;
+			}
+
+            hdmi_cec_receive_frame_kt = ktime_set(0, HDMI_CEC_CONFIRM_LOGICAL_BIT_TIME - 100000);
+			receive_frame_data.sta = data_block_receive_eom_bit;
+			receive_frame_data.receive_frame = 0x0;
+		}
+
+        break;
+
+    case data_block_receive_eom_bit:
+        if(hdmi_cec_read_reg_bit() == 0) {
+//			pr_err("+m\n");
+            receive_frame_data.eom = HDMI_CEC_MSG_EOM_MORE;
+            } else {
+//			pr_err("+e\n");
+                receive_frame_data.eom = HDMI_CEC_MSG_EOM_END;
+
+				tmpmsg.oprands_num = receive_frame_data.oprands_count;
+				receive_a_frame = 1;
+			}
+
+        receive_frame_data.sta = data_block_ack_bit_pull_down;
+        hdmi_cec_receive_frame_kt = ktime_set(0, HDMI_CEC_PULL_LOW_TIME);
+
+        break;
+
+    case data_block_ack_bit_pull_down:
+        if((receive_frame_data.header_block & 0xf) == send_frame_data.indicate_logical_adr) {
+			/*TODO set as input */
+            //sw_gpio_eint_set_enable(hdmi_cec_gpio, 0);
+            //sw_gpio_setcfg(hdmi_cec_gpio, 1);
+			hdmi_cec_pin_disable_irq();
+			hdmi_cec_pin_as_output(hdmi_cec_gpio);
+            hdmi_cec_write_reg_bit0();
+            }
+
+        receive_frame_data.sta = data_block_ack_bit_pull_up;
+        hdmi_cec_receive_frame_kt = ktime_set(0,  HDMI_CEC_DATA_BIT_LOGICAL0_LOW_TIME - HDMI_CEC_PULL_LOW_TIME);
+        goto out_hrtimer_restart;
+
+        break;
+
+    case data_block_ack_bit_pull_up:
+        if ((receive_frame_data.header_block & 0xf) == send_frame_data.indicate_logical_adr) {
+            hdmi_cec_write_reg_bit1();
+			hdmi_cec_pin_as_eint(hdmi_cec_gpio);
+			hdmi_cec_pin_enable_irq();
+
+		}
+
+        if (receive_frame_data.eom == HDMI_CEC_MSG_EOM_MORE) {
+			receive_frame_data.sta = data_block_receive_info_bit;
+			hdmi_cec_receive_frame_kt = ktime_set(0, HDMI_CEC_CONFIRM_LOGICAL_BIT_TIME);
+			receive_frame_data.flags = 8;
+			receive_frame_data.receive_frame = 0x0;
+		} else {
+			memcpy(&receive_frame_buffer[receive_frame_data.add_buf_flags], &tmpmsg,
+				sizeof(__hdmi_cec_receive_message));
+			receive_frame_data.add_buf_flags++;
+			if (receive_frame_data.add_buf_flags > 9)
+				receive_frame_data.add_buf_flags = 0;
+
+			if (receive_frame_data.current_buf_flags == receive_frame_data.add_buf_flags) {
+				receive_frame_data.current_buf_flags++;
+				if (receive_frame_data.current_buf_flags > 9)
+					receive_frame_data.current_buf_flags = 0;
+			}
+#if 0
+			pr_info("opcode: %02x\n", tmpmsg.opcode);
+			pr_info("cnt: %d, %x, %x, %x, %x\n",
+				tmpmsg.oprands_num,
+				tmpmsg.oprands[0],
+				tmpmsg.oprands[1],
+				tmpmsg.oprands[2],
+				tmpmsg.oprands[3]);
+#endif
+			//receive_frame_buffer[receive_frame_data.add_buf_flags].oprands_num = receive_frame_data.oprands_count;
+			//receive_a_frame = 1;
+			receive_frame_data.sta = judge_start_bit;
+			//hdmi_cec_receive_frame_kt = ktime_set(0, HDMI_CEC_JUDGE_START_BIT_TIME);
+		}
+        break;
+
+    default :
+        break;
+        }
+
+    return HRTIMER_NORESTART;
+
+    out_hrtimer_restart: hrtimer_forward_now(timer, hdmi_cec_receive_frame_kt);
+    return HRTIMER_RESTART;
+}
+
+//hdmi cec interrupt quest handler
+irqreturn_t hdmi_cec_gpio_irq_hdl(int irq, void *para)
+{
+	long unsigned long tmp_time;
+	tmp_time = ktime_to_ns(ktime_get()) - last_irq_time;
+	if(tmp_time >= 4200000 && tmp_time <= 4800000)
+	{
+		receive_frame_data.sta = header_block_receive_info_bit;
+		hdmi_cec_receive_frame_kt = ktime_set(0, HDMI_CEC_CONFIRM_LOGICAL_BIT_TIME);
+		receive_frame_data.flags = 8;
+		receive_frame_data.receive_frame = 0x0;
+		receive_frame_data.oprands_count= 0;
+		hrtimer_start(&hdmi_cec_receive_frame_hrtimer, hdmi_cec_receive_frame_kt, HRTIMER_MODE_REL);
+	}
+	else
+	{
+		hrtimer_start(&hdmi_cec_receive_frame_hrtimer, hdmi_cec_receive_frame_kt, HRTIMER_MODE_REL);
+		last_irq_time = ktime_to_ns(ktime_get());
+	}
+
+    return IRQ_HANDLED;
+}
+
+//start receive frame
+void hdmi_cec_start_receive_frame(void)
+{
+    hdmi_cec_receive_frame_kt = ktime_set(0, HDMI_CEC_JUDGE_START_BIT_TIME);
+    receive_frame_data.sta = judge_start_bit;
+
+    receive_frame_data.current_buf_flags= 0;
+    receive_frame_data.add_buf_flags= 0;
+
+	/* TODO */
+//    receive_frame_data.irq_request_handle = sw_gpio_irq_request(hdmi_cec_gpio, TRIG_EDGE_NEGATIVE,
+//                                                                (peint_handle)hdmi_cec_gpio_irq_hdl, (void *)hdmi_cec_gpio);
+}
+
+//get initiator address
+__u32 hdmi_cec_get_initiator_adr(void)
+{
+    return (__u32)send_frame_data.indicate_logical_adr;
+}
+
+/* receive data from userspace */
+void hdmi_cec_nl_input(struct sk_buff *skb)
+{
+    struct sk_buff *sk_b;
+    struct nlmsghdr *nlh;
+    char str[50];
+    flag = 1;
+    sk_b = skb_get(skb);
+    if(sk_b->len >= NLMSG_SPACE(0)){
+        nlh = nlmsg_hdr(sk_b);
+		memcpy(str, NLMSG_DATA(nlh), sizeof(str));
+        u_pid = nlh->nlmsg_pid;
+     }
+     kfree_skb(sk_b);
+}
+
+//get receive message
+__u32 hdmi_cec_receive_message(__hdmi_cec_receive_message *receive)
+{
+	//no message to receive
+//    if(receive_frame_data.current_buf_flags == receive_frame_data.add_buf_flags || receive_a_frame == 0)
+//        return 0;
+
+	if(receive_frame_data.current_buf_flags == receive_frame_data.add_buf_flags)
+		return 0;
+
+	memcpy(receive, &receive_frame_buffer[receive_frame_data.current_buf_flags], sizeof(__hdmi_cec_receive_message));
+	memset(&receive_frame_buffer[receive_frame_data.current_buf_flags], 0, sizeof(__hdmi_cec_receive_message));
+
+	hdmi_cec_debug("opcode: %02x\n", receive->opcode);
+	hdmi_cec_debug("cnt: %d, %x, %x, %x, %x\n",
+		receive->oprands_num,
+		receive->oprands[0],
+		receive->oprands[1],
+		receive->oprands[2],
+		receive->oprands[3]);
+
+	receive_a_frame = 0;
+    receive_frame_data.current_buf_flags++;
+    if(receive_frame_data.current_buf_flags > 9)
+        receive_frame_data.current_buf_flags = 0;
+
+    return 1;
+}
+static int hdmi_cec_open_sock(void)
+{
+	hdmi_cec_sock = netlink_kernel_create(&init_net, NETLINK_CEC, 0, hdmi_cec_nl_input, NULL, THIS_MODULE);
+	if (!hdmi_cec_sock){
+         pr_err("##open sock failed.");
+		 return -1;
+		}
+	return 0;
+}
+int hdmi_cec_close_flag(void)
+{
+    __hdmi_cec_receive_message res;
+	res.oprands_num = 0;
+	res.opcode = 0xee;
+	memset(res.oprands, 0, 14 * sizeof(unsigned long));
+	res.oprands[0] = 0;
+	hdmi_cec_sent_sock_skb(&res);
+	return 0;
+}
+static int hdmi_cec_close_sock(void)
+{
+    //send '0xee' msg to tell app to close the socket.
+    hdmi_cec_close_flag();
+	if (hdmi_cec_sock){
+		sock_release(hdmi_cec_sock->sk_socket);
+		hdmi_cec_sock->sk_socket = NULL;
+		}
+	return 0;
+}
+
+int hdmi_cec_sent_sock_skb(__hdmi_cec_receive_message* rec_p)
+{
+	struct sk_buff* sk_data;
+	struct msg_to_send msg_k;
+    int msg_len, m_len;
+	int ret;
+	if (!rec_p && !hdmi_cec_sock){
+          pr_err("##arg or sock is null");
+		  return -1;
+	}
+	if (!u_pid){
+		pr_err("##no message sent form user,the u_pid is unknown.\n");
+		return 0;
+	}
+    /* total size of message */
+	m_len = NLMSG_SPACE(sizeof (msg_k));
+	sk_data = alloc_skb(m_len,GFP_ATOMIC);
+	if(!sk_data){
+		pr_err("##alloc_skb error.");
+		  return -1;
+	}
+	msg_k.nlh = nlmsg_put(sk_data,0,0,0,m_len,0);
+	NETLINK_CB(sk_data).pid = 0;
+    NETLINK_CB(sk_data).dst_group = 0;
+	msg_len = sizeof(msg_k.sec);
+	/* store rec_p in the sk_buff */
+	memcpy(NLMSG_DATA(msg_k.nlh),rec_p,msg_len);
+
+    ret = netlink_unicast(hdmi_cec_sock, sk_data, u_pid, MSG_DONTWAIT);
+	return 0;
+}
+
+static void send_cec_data_to_app(__hdmi_cec_receive_message *send_data)
+{
+#if 0
+    char buf1[64];
+	char buf2[64];
+	char tmp[64];
+	char *envp[3];
+	int i;
+
+	/*format: CECDATA=opcode;oprands_num */
+	snprintf(buf1, sizeof(buf1), "CECDATA=%x;%d",send_data->opcode,send_data->oprands_num);
+	envp[0] = buf1;
+	/* oprands */
+	if(send_data->oprands_num == 0){
+		tmp[0] = '\0';
+	}else {
+	    for (i = 0;i < send_data->oprands_num && i < 64; i++){
+           tmp[i] = (char)send_data->oprands[i];
+	    printk("## get oprands[%d] = %x\n", i, send_data->oprands[i]);
+		}
+		tmp[++i] = '\0';
+	}
+	/*format: OPRAND=oprand */
+    snprintf(buf2, sizeof(buf2), "OPRAND=%s",tmp);
+	envp[1] = buf2;
+	envp[2] = NULL;
+
+	kobject_uevent_env(&ghdmi.dev->kobj, KOBJ_CHANGE, envp);
+	__Cinf("##send_data->opcode =%x\n",send_data->opcode);
+	#endif
+}
+
+int hdmi_cec_run_thread(void *parg)
+{
+	while(1) {
+		__hdmi_cec_receive_message cec_receive_data;
+
+		if (kthread_should_stop()) {
+			pr_info("hdmi_cec_run_thread, hdmi suspend\n");
+			break;
+		}
+
+		if (hdmi_cec_polling_complete == 1) {
+			hdmi_cec_prepare();
+			msleep(100);
+		}
+
+		if (hdmi_cec_receive_message(&cec_receive_data) == 1) {
+			send_cec_data_to_app(&cec_receive_data);
+			__disp_cec_data_process(&cec_receive_data);
+
+			//printk("##send opcode =0x%x oprands_num = %d\n",cec_receive_data.opcode, cec_receive_data.oprands_num);
+			//for (i = 0;i < cec_receive_data.oprands_num && i < 64; i++)
+			//	printk("oprands[%d] = %x\n", i, cec_receive_data.oprands[i]);
+		}
+		msleep(100);
+	}
+	return 0;
+}
+
+static int hdmi_cec_input_dev(void)
+{
+	int i;
+	int ret;
+	hdmicecdev = input_allocate_device();
+	if (!hdmicecdev) {
+		printk("alloc hdmi cec input dev failed\n");
+		return -ENODEV;
+	}
+
+	hdmicecdev->name = "hdmi-cec";
+	hdmicecdev->phys = "";
+	hdmicecdev->id.bustype = BUS_HOST;
+	hdmicecdev->id.vendor = 0x0001;
+	hdmicecdev->id.product = 0x0001;
+	hdmicecdev->id.version = 0x0100;
+	hdmicecdev->open = NULL;
+	hdmicecdev->close = NULL;
+	set_bit(EV_KEY, hdmicecdev->evbit);
+
+	for(i=0; i < sizeof(cec_key_tab)/sizeof(__disp_cec_key_tab); i++)
+		set_bit(cec_key_tab[i].input_key, hdmicecdev->keybit);
+
+	ret = input_register_device(hdmicecdev);
+	if(ret) {
+		printk("Unable to Register the hdmi cec key\n");
+	}
+
+	return ret;
+}
+
+static int hdmi_cec_init(void)
+{
+	int ret;
+	script_item_u val;
+	script_item_value_type_e type;
+
+	type = script_get_item("hdmi_cec", "hdmi_cec_used", &val);
+	if (SCIRPT_ITEM_VALUE_TYPE_INT != type) {
+		pr_err("%s: hdmi_cec script_get_item err.\n", __func__);
+		hdmi_cec_used = 0;
+		return -1;
+	}
+	hdmi_cec_used = val.val;
+
+	if (!hdmi_cec_used)
+		return -1;
+
+	type = script_get_item("hdmi_cec", "hdmi_cec_pin", &val);
+	if (SCIRPT_ITEM_VALUE_TYPE_PIO != type) {
+		pr_err("%s: hdmi_cec script_get_item err.\n", __func__);
+		return -1;
+	}
+	hdmi_cec_gpio = val.gpio.gpio;
+	hdmi_cec_irqnum = gpio_to_irq(hdmi_cec_gpio);
+
+	ret = gpio_request(hdmi_cec_gpio, "hdmi-cec-pin");
+	if (ret!=0) {
+		pr_err("%s: request hdmi-cec-pin error\n", __func__);
+		return -1;
+	}
+
+	ret = hdmi_cec_input_dev();
+	if (ret!=0) {
+		pr_err("%s: register input device failed\n", __func__);
+		goto _register_inputdev_err;
+	}
+
+	/* request virq, set virq type to high level trigger */
+	ret = devm_request_irq(&hdmicecdev->dev, hdmi_cec_irqnum, hdmi_cec_gpio_irq_hdl,
+			IRQF_TRIGGER_FALLING, "hdmi_cec_int", NULL);
+	if (IS_ERR_VALUE(ret)) {
+		pr_err("request virq %d failed, errno = %d\n",
+			hdmi_cec_irqnum, ret);
+		goto _register_irq_err;
+    }
+
+    //init polling message
+    polling_mes_data.broadcast_complete_flags = 0;
+    hrtimer_init(&hdmi_cec_polling_message_hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+    hdmi_cec_polling_message_hrtimer.function = hdmi_cec_polling_hrtimer_handler;
+
+    //init send frame variable
+    hrtimer_init(&hdmi_cec_send_frame_hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+    hdmi_cec_send_frame_hrtimer.function = hdmi_cec_send_frame_hrtimer_handler;
+
+    send_frame_data.indicate_logical_adr = HDMI_CEC_LADDR_PLAYER1;
+    send_frame_data.follower_logical_adr = HDMI_CEC_LADDR_TV;
+
+    if(send_frame_data.follower_logical_adr == HDMI_CEC_LADDR_BROADCAST)
+        send_frame_data.ack = HDMI_CEC_MSG_ACK_BROADCAST;
+    else
+        send_frame_data.ack = HDMI_CEC_MSG_ACK_NORMAL;
+
+    send_frame_data.add_buf_flags = 0;
+    send_frame_data.current_buf_flags = 0;
+
+    /*init receive frame variable */
+    hrtimer_init(&hdmi_cec_receive_frame_hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+    hdmi_cec_receive_frame_hrtimer.function = hdmi_cec_receive_frame_hrtimer_handler;
+	cec_task = kthread_create(hdmi_cec_run_thread, (void*)0, "cec-thread");
+	if(IS_ERR(cec_task))
+	{
+		ret = PTR_ERR(cec_task);
+		cec_task = NULL;
+		pr_err("Unable to start kernel thread %s. ret = %x\n","cec proc", ret);
+		goto _thread_create_err;
+	}
+	wake_up_process(cec_task);
+    //hdmi_cec_open_sock();     /* if use netlink to send data,open it */
+    hdmi_cec_start_receive_frame();
+
+	mutex_init(&mutex_msg_send);
+	return 0;
+
+_thread_create_err:
+    hrtimer_cancel(&hdmi_cec_send_frame_hrtimer);
+    hrtimer_cancel(&hdmi_cec_receive_frame_hrtimer);
+//	free_irq(hdmi_cec_irqnum, NULL); /* free by input device */
+_register_irq_err:
+	input_unregister_device(hdmicecdev);
+_register_inputdev_err:
+	gpio_free(hdmi_cec_gpio);
+	return -EINVAL;
+}
+
+static void hdmi_cec_exit(void)
+{
+    //cancel high resolution timer
+    hrtimer_cancel(&hdmi_cec_send_frame_hrtimer);
+    hrtimer_cancel(&hdmi_cec_receive_frame_hrtimer);
+
+    //free gpio
+	gpio_free(hdmi_cec_gpio);
+
+	if(cec_task)
+	{
+		kthread_stop(cec_task);
+		cec_task = 0;
+	}
+	//hdmi_cec_close_sock();
+	input_unregister_device(hdmicecdev);
+}
+
+static struct platform_device *pdev;
+
+static ssize_t hdmi_cec_show(struct class *class,
+		struct class_attribute *attr, char *buf)
+{
+#if 0
+	volatile int *config = (volatile int *)(0xf1c20800 + 0x08);
+	volatile int *data   = (volatile int *)(0xf1c20800 + 0x10);
+	int config_val = *config;
+	int data_val   = *data;
+
+	return sprintf(buf, "config: 0x%08x\ndata  : 0x%08x\n",
+		config_val & (0xf<<20), data_val & (1<<21));
+#endif
+	int phy_addr = hdmi_cec_phy_addr;
+
+	return sprintf(buf, "physical address: %d.%d.%d.%d\n",
+			(phy_addr>>12)&0xf, (phy_addr>>8)&0xf,
+			(phy_addr>> 4)&0xf, (phy_addr>>0)&0xf);
+}
+
+static ssize_t hdmi_cec_store(struct class *class,
+		struct class_attribute *attr, const char *buf, size_t count)
+{
+	char type = *buf;
+
+	hdmi_cec_debug("config as: %c\n", type);
+
+	switch(type) {
+		case 'e':
+			hdmi_cec_pin_as_eint(hdmi_cec_gpio);
+			break;
+		case 'i':
+			disable_irq_nosync(hdmi_cec_irqnum);
+			hdmi_cec_pin_as_input(hdmi_cec_gpio);
+			break;
+		case '0':
+		case '1':
+		case 'o':
+			disable_irq_nosync(hdmi_cec_irqnum);
+			hdmi_cec_pin_as_output(hdmi_cec_gpio);
+			if (type=='1') hdmi_cec_write_reg_bit1();
+			if (type=='0') hdmi_cec_write_reg_bit0();
+			break;
+		case 'p':
+			hdmi_cec_polling_message();
+			break;
+		case 's':
+			__disp_set_standby_to_tv();
+			//__disp_set_cec_power_status_to_tv();
+			break;
+		case 'v':
+			__disp_set_cec_image_view_on();
+			break;
+		case 'g':
+			__disp_get_menu_language();
+			break;
+		default:
+			pr_err("%s: unknown pin type\n", __func__);
+			break;
+	}
+
+	return count;
+}
+
+static struct class_attribute hdmi_cec_class_attrs[] = {
+	__ATTR(hdmi_cec,
+	       S_IRUGO | S_IWUSR,
+	       hdmi_cec_show,
+	       hdmi_cec_store),
+	__ATTR_NULL
+};
+
+static struct class hdmi_cec_class = {
+	.name = "hdmi-cec",
+	.class_attrs = hdmi_cec_class_attrs,
+
+};
+
+#if defined(CONFIG_HAS_EARLYSUSPEND)
+void hdmi_cec_early_suspend(struct early_suspend *h)
+{
+	__disp_set_standby_to_tv();
+	msleep(200);
+}
+
+void hdmi_cec_late_resume(struct early_suspend *h)
+{
+	__disp_set_cec_image_view_on();
+	msleep(200);
+}
+
+static struct early_suspend hdmi_cec_early_suspend_handler =
+{
+	.level   = EARLY_SUSPEND_LEVEL_DISABLE_FB + 300,
+	.suspend = hdmi_cec_early_suspend,
+	.resume  = hdmi_cec_late_resume,
+};
+#endif
+
+/* Device model stuff */
+static int hdmi_cec_probe(struct platform_device *dev)
+{
+	int ret;
+
+	ret = hdmi_cec_init();
+
+	if (!ret) {
+		register_early_suspend(&hdmi_cec_early_suspend_handler);
+		class_register(&hdmi_cec_class);
+		printk(KERN_INFO "hdmi-cec: device successfully initialized.\n");
+	}
+
+	hdmi_cec_polling_message();
+	return ret;
+}
+
+static int hdmi_cec_remove(struct platform_device *dev)
+{
+	class_unregister(&hdmi_cec_class);
+	unregister_early_suspend(&hdmi_cec_early_suspend_handler);
+	hdmi_cec_exit();
+	printk(KERN_INFO "hdmi-cec: device successfully initialized.\n");
+	return 0;
+}
+
+#if 0
+static int hdmi_cec_suspend(struct platform_device *dev, pm_message_t state)
+{
+	__disp_set_standby_to_tv();
+	msleep(200);
+	return 0;
+
+}
+static int hdmi_cec_resume(struct platform_device *dev)
+{
+	__disp_set_cec_image_view_on();
+	msleep(200);
+	return 0;
+}
+#endif
+
+
+void hdmi_cec_shutdown(struct platform_device *dev)
+{
+	__disp_set_standby_to_tv();
+	msleep(200);
+}
+
+static struct platform_driver hdmi_cec_driver = {
+	.probe   = hdmi_cec_probe,
+	.remove  = hdmi_cec_remove,
+	.shutdown = hdmi_cec_shutdown,
+#if 0
+	.suspend = hdmi_cec_suspend,
+	.resume  = hdmi_cec_resume,
+#endif
+	.driver = {
+		.name = "hdmi-cec",
+		.owner = THIS_MODULE,
+	},
+};
+
+/* Module stuff */
+static int __init hdmi_cec_platform_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&hdmi_cec_driver);
+	if (ret)
+		goto out;
+
+	pdev = platform_device_register_simple("hdmi-cec", -1, NULL, 0);
+	if (IS_ERR(pdev)) {
+		ret = PTR_ERR(pdev);
+		goto out_driver;
+	}
+
+	printk(KERN_INFO "hdmi-cec: driver successfully loaded.\n");
+	return 0;
+
+out_driver:
+	platform_driver_unregister(&hdmi_cec_driver);
+out:
+	printk(KERN_WARNING "hdmi-cec: driver init failed (ret=%d)!\n",
+	       ret);
+	return ret;
+}
+
+static void __exit hdmi_cec_platform_exit(void)
+{
+	platform_device_unregister(pdev);
+	platform_driver_unregister(&hdmi_cec_driver);
+
+	printk(KERN_INFO "hdmi-cec: driver unloaded.\n");
+}
+
+module_init(hdmi_cec_platform_init);
+module_exit(hdmi_cec_platform_exit);
+module_param_named(debug_mask, debug_mask, int, 0644);
+
+MODULE_DESCRIPTION("AllwinnerTech hdmi cec driver");
+MODULE_LICENSE("GPL");
diff -Nur a/drivers/video/sunxi/disp2/hdmi/aw/hdmi_cec.h cec_bitbang/drivers/video/sunxi/disp2/hdmi/aw/hdmi_cec.h
--- a/drivers/video/sunxi/disp2/hdmi/aw/hdmi_cec.h	1970-01-01 01:00:00.000000000 +0100
+++ cec_bitbang/drivers/video/sunxi/disp2/hdmi/aw/hdmi_cec.h	2016-03-10 17:53:08.881904514 +0100
@@ -0,0 +1,259 @@
+#ifndef __HDMI_CEC_H__
+#define __HDMI_CEC_H__
+
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+//#include "hdmi_core.h"
+#include <linux/regulator/consumer.h>
+#include <linux/err.h>
+
+#define hdmi_cec_reg_offset 0x214
+#define hdmi_cec_enable_reg_bit_offset 0x800
+#define hdmi_cec_write_reg_bit_offset 0x200
+#define hdmi_cec_read_reg_bit_offset 0x100
+
+//polling message time unit : ns
+#define HDMI_CEC_PRE_POLLING_MESSAGE_TIME 600000
+#define HDMI_CEC_WAIT_BROADCAST_COMPLETE 30000000
+
+//send frame time unit:ns
+#define HDMI_CEC_PRE_SEND_MESSAGE_TIME 600000
+
+#define HDMI_CEC_START_BIT_LOW_TIME 3700000
+#define HDMI_CEC_START_BIT_HIGH_TIME 800000
+
+#define HDMI_CEC_PULL_LOW_TIME 200000
+
+#define HDMI_CEC_DATA_BIT_LOGICAL0_LOW_TIME 1500000
+#define HDMI_CEC_DATA_BIT_LOGICAL1_LOW_TIME 600000
+#define HDMI_CEC_DATA_BIT_WHOLE_TIME 2400000
+
+#define HDMI_CEC_DATA_BIT_ACK_INVALID_TIME 400000
+#define HDMI_CEC_DATA_BIT_ACK_SET_LOW_TIME 1400000
+
+#define HDMI_CEC_CONTINUE_SEND_ANOTHER_MESSAGE 20000000
+
+//receive frame time unit:ns
+#define HDMI_CEC_JUDGE_START_BIT_TIME 1900000
+#define HDMI_CEC_CONFIRM_START_BIT_TIME 2200000
+#define HDMI_CEC_CONFIRM_LOGICAL_BIT_TIME 1000000
+
+#define HDMI_CEC_OSD_NAME  "aw-soft.CEC"
+
+
+#if 1
+
+#define _CEC_INFO  (1<<0)
+#define _CEC_DEBUG (1<<1)
+
+#define hdmi_cec_info( format, args... )      \
+do {                                          \
+    if(unlikely(debug_mask&_CEC_INFO)){       \
+        printk(KERN_INFO format, ##args); \
+    }                                         \
+}while(0)
+
+#define hdmi_cec_debug( format, args... )      \
+do {                                           \
+    if(unlikely(debug_mask&_CEC_DEBUG)){       \
+        printk(KERN_DEBUG format, ##args); \
+    }                                          \
+}while(0)
+
+#else
+
+#define hdmi_cec_info( format, args... )
+#define hdmi_cec_debug( format, args... )
+
+#endif
+
+#define hdmi_cec_err( format, args... )    \
+do {                                       \
+    printk(KERN_ERR format, ##args);   \
+}while(0)
+
+typedef enum {
+    pre_polling_mes,
+    start_polling_bit,
+    polling_mes_set_info_bit,
+    polling_mes_set_eom_bit,
+    polling_mes_set_ack_bit,
+    polling_mes_get_ack_bit,
+    continue_polling_mes,
+    complete_polling_mes,
+}__hdmi_cec_polling_message_status;
+
+typedef enum {
+    pre_send_mes,
+    start_bit,
+    header_block_set_info_bit,
+    header_block_set_eom_bit,
+    header_block_set_ack_bit,
+    header_block_get_ack_bit,
+    opcode_block_set_info_bit,
+    opcode_block_set_eom_bit,
+    opcode_block_set_ack_bit,
+    opcode_block_get_ack_bit,
+    oprands_block_set_info_bit,
+    oprands_block_set_eom_bit,
+    oprands_block_set_ack_bit,
+    oprands_block_get_ack_bit,
+    wait_for_hdmi_connect,
+    continue_send_mes,
+}__hdmi_cec_send_frame_status;
+
+typedef enum {
+    judge_start_bit,
+    confirm_start_bit,
+    header_block_receive_info_bit,
+    header_block_receive_eom_bit,
+    header_block_ack_bit_pull_down,
+    header_block_ack_bit_pull_up,
+    data_block_receive_info_bit,
+    data_block_receive_eom_bit,
+    data_block_ack_bit_pull_down,
+    data_block_ack_bit_pull_up,
+}__hdmi_cec_receive_frame_status;
+
+typedef enum {
+    HDMI_CEC_LADDR_TV,
+    HDMI_CEC_LADDR_RECORDER1,
+    HDMI_CEC_LADDR_RECORDER2,
+    HDMI_CEC_LADDR_TUNER1,
+    HDMI_CEC_LADDR_PLAYER1,
+    HDMI_CEC_LADDR_AUDIO,
+    HDMI_CEC_LADDR_TUNER2,
+    HDMI_CEC_LADDR_TUNER3,
+    HDMI_CEC_LADDR_PLAYER2,
+    HDMI_CEC_LADDR_RECORDER3,
+    HDMI_CEC_LADDR_TUNER4,
+    HDMI_CEC_LADDR_PLAYER3,
+    HDMI_CEC_LADDR_RESERVED1,
+    HDMI_CEC_LADDR_RESERVED2,
+    HDMI_CEC_LADDR_SPECIFIC,
+    HDMI_CEC_LADDR_BROADCAST,
+}__hdmi_cec_logical_address;
+
+typedef enum {
+    HDMI_CEC_IMAGE_VIEW_ON                 = 0x04,
+    HDMI_CEC_TEXT_VIEW_ON                  = 0x0d,
+    HDMI_CEC_GIVE_DECK_STATUS              = 0x1a,
+    HDMI_CEC_DECK_STATUS                   = 0x1b,
+	HDMI_CEC_SET_MENU_LANGUAGE             = 0x32,
+    HDMI_CEC_STANDBY                       = 0x36,
+    HDMI_CEC_PLAY                          = 0x41,
+    HDMI_CEC_DECK_CONTROL                  = 0x42,
+    HDMI_CEC_SET_OSD_NAME                  = 0x47,
+    HDMI_CEC_SENT_ROUTING_INFORMATION      = 0x81,
+	HDMI_CEC_ACTIVE_SOURCE                 = 0x82,
+    HDMI_CEC_REPORT_PHY_ADDR               = 0X84,
+    HDMI_CEC_REQUEST_ACTIVE_SOURCE         = 0x85,
+    HDMI_CEC_SENT_VERDOR_ID                = 0x87,
+	HDMI_CEC_SENT_VERDOR_COMMAND           = 0x89,
+    HDMI_CEC_MENU_STATE                    = 0x8e,
+    HDMI_CEC_GIVE_POWER_STATUS             = 0x8f,
+    HDMI_CEC_REPORT_POWER_STATUS           = 0x90,
+	HDMI_CEC_GET_MENU_LANGUAGE             = 0x91,
+    HDMI_CEC_INACTIVE_SOURCE               = 0x9d,
+	HDMI_CEC_REPORT_CEC_VERSION            = 0x9e,
+}__hdmi_cec_opcode;
+
+typedef enum {
+    HDMI_CEC_MSG_EOM_MORE,
+    HDMI_CEC_MSG_EOM_END,
+}__hdmi_cec_msg_eom;
+
+typedef enum {
+    HDMI_CEC_MSG_ACK_NORMAL,
+    HDMI_CEC_MSG_ACK_BROADCAST,
+}__hdmi_cec_msg_ack;
+
+typedef enum {
+    PIN_FAIL     	= -24,
+	PIN_NUM_ERR   	= -25,
+	GPIO_ERR       = -26,
+}__hdmi_cec_err;
+
+typedef struct {
+	int hdmi_cec_used;
+	__u32  hdmi_cec_pin;
+	__u32  hdmi_cec_pin_num;
+}__hdmi_cec_cfg;
+
+typedef struct {
+    __u32 header_block;
+    __hdmi_cec_polling_message_status sta;
+    __u32 status_flags;
+    __u32 broadcast_flags;
+    __u32 broadcast_complete_flags;
+}__hdmi_cec_polling_message_data;
+
+typedef struct {
+    __hdmi_cec_send_frame_status sta;
+    __hdmi_cec_logical_address indicate_logical_adr;
+    __hdmi_cec_logical_address follower_logical_adr;
+    __u32 header_block;
+    __hdmi_cec_msg_eom eom;
+    __hdmi_cec_msg_ack ack;
+    __u32 flags;
+    __u32 oprands_count;
+    __u32 oprands_num;
+    __u32 resend_flags;
+    __u32 opcode_flags;
+    __u32 current_buf_flags;
+    __u32 add_buf_flags;
+    __u32 status_flags;
+}__hdmi_cec_send_frame_data;
+
+typedef struct {
+    u32 irq_request_handle;
+    __hdmi_cec_receive_frame_status sta;
+    __u32 header_block;
+    __hdmi_cec_msg_eom eom;
+    __hdmi_cec_msg_ack ack;
+    __u32 flags;
+    __u32 receive_frame;
+    __u32 oprands_count;
+    __u32 opcode_flags;
+    __u32 add_buf_flags;
+    __u32 current_buf_flags;
+}__hdmi_cec_receive_frame_data;
+
+typedef struct {
+    __u32 oprands_num;
+    __u32 opcode_flags;
+    __u32 follower_adr;
+    __u32 opcode;
+    __u32 oprands[14];
+}__hdmi_cec_send_message;
+
+typedef struct {
+    __u32 oprands_num;
+    __u32 opcode;
+    __u32 oprands[14];
+}__hdmi_cec_receive_message;
+
+struct msg_to_send {
+    struct nlmsghdr *nlh;
+	__hdmi_cec_receive_message sec;
+};
+
+__u32 hdmi_cec_get_pin(void);
+__u32 hdmi_cec_get_pin_num(void);
+__u32 hdmi_cec_set_gpio(__u32 pin,__u32 num);
+void hdmi_cec_clear_polling_flags(void);
+int __disp_set_cec_hdmi_ch(void);
+void hdmi_cec_polling_message(void);
+void hdmi_send_message(__hdmi_cec_send_message *mes);
+void hdmi_cec_start_receive_frame(void);
+irqreturn_t hdmi_cec_gpio_irq_hdl(int irq, void *para);
+__u32 hdmi_cec_get_initiator_adr(void);
+__u32 hdmi_cec_receive_message(__hdmi_cec_receive_message * receive);
+int hdmi_cec_sent_sock_skb(__hdmi_cec_receive_message* rec);
+void hdmi_cec_nl_input(struct sk_buff* skb);
+int hdmi_cec_close_flag(void);
+
+//int hdmi_cec_init(void);
+//void hdmi_cec_exit(void);
+
+#endif
diff -Nur a/drivers/video/sunxi/disp2/hdmi/Makefile cec_bitbang/drivers/video/sunxi/disp2/hdmi/Makefile
--- a/drivers/video/sunxi/disp2/hdmi/Makefile	2015-01-27 03:29:32.000000000 +0100
+++ cec_bitbang/drivers/video/sunxi/disp2/hdmi/Makefile	2016-03-10 17:53:08.877903782 +0100
@@ -4,3 +4,5 @@
 hdmi-$(CONFIG_ARCH_SUN8IW6) += aw/hdmi_bsp_sun8iw6.o
 hdmi-$(CONFIG_ARCH_SUN8IW7) += aw/hdmi_bsp_sun8iw7.o
 
+
+obj-$(CONFIG_SUNXI_HDMI_CEC) += aw/hdmi_cec.o
diff -Nur a/drivers/video/sunxi/Kconfig cec_bitbang/drivers/video/sunxi/Kconfig
--- a/drivers/video/sunxi/Kconfig	2015-01-27 03:29:31.000000000 +0100
+++ cec_bitbang/drivers/video/sunxi/Kconfig	2016-03-10 17:53:08.877903782 +0100
@@ -91,4 +91,10 @@
   default n
   ---help---
 
+config SUNXI_HDMI_CEC
+  tristate "HDMI CEC driver for sunxi-disp2"
+  depends on DISP2_SUNXI
+  default m
+  ---help---
+
 endmenu
diff -Nur a/include/linux/netlink.h cec_bitbang/include/linux/netlink.h
--- a/include/linux/netlink.h	2015-01-27 03:29:37.000000000 +0100
+++ cec_bitbang/include/linux/netlink.h	2016-03-10 17:53:08.881904514 +0100
@@ -26,6 +26,7 @@
 #define NETLINK_ECRYPTFS	19
 #define NETLINK_RDMA		20
 #define NETLINK_CRYPTO		21	/* Crypto layer */
+#define NETLINK_CEC			22
 
 #define NETLINK_INET_DIAG	NETLINK_SOCK_DIAG
 
